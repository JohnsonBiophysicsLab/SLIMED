\hypertarget{Linear__algebra_8hpp}{}\doxysection{include/\+Linear\+\_\+algebra.hpp File Reference}
\label{Linear__algebra_8hpp}\index{include/Linear\_algebra.hpp@{include/Linear\_algebra.hpp}}
{\ttfamily \#include $<$vector$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$gsl/gsl\+\_\+matrix.\+h$>$}\newline
{\ttfamily \#include $<$gsl/gsl\+\_\+blas.\+h$>$}\newline
{\ttfamily \#include $<$gsl/gsl\+\_\+linalg.\+h$>$}\newline
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classMatrix}{Matrix}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classMatrix}{Matrix}} used in continuum membrane model. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \mbox{\hyperlink{Linear__algebra_8hpp_af45abfc5a0e5e23d8aabcea64c339312}{mat\+\_\+calloc}} (const int \&nrow, const int \&ncol)
\begin{DoxyCompactList}\small\item\em This function allocates a new \mbox{\hyperlink{classMatrix}{Matrix}} object with the specified number of rows and columns, and initializes all elements to zero. \end{DoxyCompactList}\item 
std\+::ostream \& \mbox{\hyperlink{Linear__algebra_8hpp_a391be9262318fa95cf1c7c21d0afa0f9}{operator$<$$<$}} (std\+::ostream \&stream, const \mbox{\hyperlink{classMatrix}{Matrix}} \&matrix)
\begin{DoxyCompactList}\small\item\em Bit push all element of a matrix in the format of\+: \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \& \mbox{\hyperlink{Linear__algebra_8hpp_a2d1976903224767c788b0f3e5846bd6c}{operator+=}} (\mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2)
\begin{DoxyCompactList}\small\item\em This implementation takes two gsl\+\_\+matrix pointers as arguments and adds the elements of the second matrix to the first matrix. It first checks that the matrices have the same dimensions, and throws an exception if they do not. Then it iterates over the elements of the matrices and adds the corresponding elements. Finally, it returns a pointer to the modified first matrix. Note that this implementation modifies the first matrix in place, rather than creating a new matrix. If you want to create a new matrix instead, you could modify the implementation accordingly. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \mbox{\hyperlink{Linear__algebra_8hpp_aa5a9f2db2b3c1862c9c0d19241239ce7}{operator+}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2)
\begin{DoxyCompactList}\small\item\em This implementation checks that the matrices have the same dimensions and allocates memory for the result of the addition. It then adds the matrices element-\/wise and stores the result in a newly allocated matrix result, which is then returned. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \& \mbox{\hyperlink{Linear__algebra_8hpp_a279fb974b0ba51b716f08f8f74417acc}{operator-\/=}} (\mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2)
\begin{DoxyCompactList}\small\item\em This implementation takes two gsl\+\_\+matrix pointers as arguments and subtract the elements of the second matrix from the first matrix. It first checks that the matrices have the same dimensions, and throws an exception if they do not. Then it iterates over the elements of the matrices and adds the corresponding elements. Finally, it returns a pointer to the modified first matrix. Note that this implementation modifies the first matrix in place, rather than creating a new matrix. If you want to create a new matrix instead, you could modify the implementation accordingly. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \mbox{\hyperlink{Linear__algebra_8hpp_a52ad5ef4b9998529c85e8523c20d6b86}{operator-\/}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2)
\begin{DoxyCompactList}\small\item\em This implementation checks that the matrices have the same dimensions and allocates memory for the result of the subtraction. It then adds the matrices element-\/wise and stores the result in a newly allocated matrix result, which is then returned. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \& \mbox{\hyperlink{Linear__algebra_8hpp_a3fdf5f190807099ee79e068f83eb517e}{operator$\ast$=}} (\mbox{\hyperlink{classMatrix}{Matrix}} \&mat, const double \&scalar)
\begin{DoxyCompactList}\small\item\em This implementation uses the gsl\+\_\+matrix\+\_\+scale function to scale each element in the matrix by the scalar value. The function returns the modified matrix, which allows for method chaining when using the $\ast$= operator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \& \mbox{\hyperlink{Linear__algebra_8hpp_a4a0a835103a72d65a8d4038c34d4a773}{operator$\ast$=}} (\mbox{\hyperlink{classMatrix}{Matrix}} m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2)
\begin{DoxyCompactList}\small\item\em This implementation checks that the matrices have compatible dimensions for multiplication and uses the BLAS library to perform the matrix multiplication. The result is stored in a temporary matrix, which is then copied back into m1. Finally, the temporary memory is freed before returning m1. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \& \mbox{\hyperlink{Linear__algebra_8hpp_a4982f65adbc5a3f46660ba7eb704b3c4}{operator/=}} (\mbox{\hyperlink{classMatrix}{Matrix}} \&mat, const double \&scalar)
\begin{DoxyCompactList}\small\item\em This implementation uses the gsl\+\_\+matrix\+\_\+scale function to scale each element in the matrix by 1/the scalar value. The function returns the modified matrix, which allows for method chaining when using the $\ast$= operator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \mbox{\hyperlink{Linear__algebra_8hpp_a287766f48ce1537b4789b890515572cb}{operator/}} (\mbox{\hyperlink{classMatrix}{Matrix}} matrix, const double \&scalar)
\begin{DoxyCompactList}\small\item\em This operator takes a double scalar and a matrix as its operands. It returns a new gsl\+\_\+matrix$\ast$ that is the result of scaling the input matrix by 1/scalar. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{Linear__algebra_8hpp_a16f2d841a7bbc07c6ed264848e532536}{dot\+\_\+col}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2)
\begin{DoxyCompactList}\small\item\em This implementation takes two column vectors as arguments and returns their dot product as double. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{Linear__algebra_8hpp_a1321d248693d484c54370beae277e19d}{dot\+\_\+row}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2)
\begin{DoxyCompactList}\small\item\em This implementation takes two row vectors as arguments and returns their dot product as double. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \mbox{\hyperlink{Linear__algebra_8hpp_a74ef398ea342aaaa6bef5128e9bf15a8}{cross\+\_\+col}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2)
\begin{DoxyCompactList}\small\item\em This implementation takes two column vectors as arguments and returns their cross product as a new column vector. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \mbox{\hyperlink{Linear__algebra_8hpp_a8c3bf9ef46fde8b009e48d735c668d93}{cross\+\_\+row}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2)
\begin{DoxyCompactList}\small\item\em This implementation takes two row vectors as arguments and returns their cross product as a new row vector. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{Linear__algebra_8hpp_ae5fa66935b125fb2613ffe2ce57e935f}{negative}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, \mbox{\hyperlink{classMatrix}{Matrix}} \&m\+\_\+neg)
\begin{DoxyCompactList}\small\item\em Computes the negative of a given matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{Linear__algebra_8hpp_a4baa40e609ed63be814718a4b8dd2f56}{get\+\_\+unit\+\_\+vector}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, \mbox{\hyperlink{classMatrix}{Matrix}} \&m\+\_\+unit)
\begin{DoxyCompactList}\small\item\em Get the unit vector in the direction of m1 which is a (3, 1) \mbox{\hyperlink{classMatrix}{Matrix}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{Linear__algebra_8hpp_aa61de292b027fd1d36cd57eb8a679c65}{cross}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2, \mbox{\hyperlink{classMatrix}{Matrix}} \&temp)
\begin{DoxyCompactList}\small\item\em Compute the cross product of two 3D vectors represented as 3x1 matrices. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{Linear__algebra_8hpp_a27119e610bb0a9292cc9f7ed26a4b173}{addition}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2, \mbox{\hyperlink{classMatrix}{Matrix}} \&tmp)
\begin{DoxyCompactList}\small\item\em Compute the element-\/wise addition of two matrices and store the result in a third matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{Linear__algebra_8hpp_a16c686d2f9ed45866109caffe69b246b}{subtraction}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2, \mbox{\hyperlink{classMatrix}{Matrix}} \&tmp)
\begin{DoxyCompactList}\small\item\em Compute the element-\/wise subtraction of two matrices and store the result in a third matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{Linear__algebra_8hpp_a7babd9d5d81db0f04b3e8fccc0ca0e76}{multiplication}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2, \mbox{\hyperlink{classMatrix}{Matrix}} \&tmp)
\begin{DoxyCompactList}\small\item\em Multiply a matrix by a constant and store the result in a second matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{Linear__algebra_8hpp_ae8380f2d0eae7bf33cdb07560747ea72}{const\+\_\+multiplication}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const double num, \mbox{\hyperlink{classMatrix}{Matrix}} \&tmp)
\begin{DoxyCompactList}\small\item\em Multiply a matrix by a constant and store the result in a second matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{Linear__algebra_8hpp_a91de41df159ee60f4eecc860c7089c9b}{const\+\_\+division}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const double num, \mbox{\hyperlink{classMatrix}{Matrix}} \&tmp)
\begin{DoxyCompactList}\small\item\em Divide a matrix by a constant and store the result in a second matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{Linear__algebra_8hpp_a71cbe43985593c79552d1e40002e5bbb}{colvec\+\_\+matrix\+\_\+multiplication}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&v1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, \mbox{\hyperlink{classMatrix}{Matrix}} \&tmp)
\begin{DoxyCompactList}\small\item\em Multiply a row vector by a matrix and store the result in a row vector. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \mbox{\hyperlink{Linear__algebra_8hpp_a476d951514d654f916418cee7d5b189f}{kron}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&v1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&v2)
\begin{DoxyCompactList}\small\item\em the Kronecker product between two column matrices and returns the result in an output matrix. The Kronecker product is defined as follows\+: \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \mbox{\hyperlink{Linear__algebra_8hpp_ae0131af41656cb51262343c655b461a4}{kron}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&v1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&v2, \mbox{\hyperlink{classMatrix}{Matrix}} \&m\+\_\+result)
\begin{DoxyCompactList}\small\item\em the Kronecker product between two column matrices and returns the result in an output matrix. The Kronecker product is defined as follows\+: \end{DoxyCompactList}\item 
void \mbox{\hyperlink{Linear__algebra_8hpp_ae19df5533c4af952dfe47bb010b66646}{assign\+\_\+row\+Vec\+\_\+to\+\_\+col\+Vec}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&src\+Row\+Vec, \mbox{\hyperlink{classMatrix}{Matrix}} \&dest\+Col\+Vec)
\item 
void \mbox{\hyperlink{Linear__algebra_8hpp_a2f238a65f9bad9ee75cd16eeae374eda}{a\+\_\+cross\+\_\+b\+\_\+plus\+\_\+c\+\_\+cross\+\_\+d}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&a, const \mbox{\hyperlink{classMatrix}{Matrix}} \&b, const \mbox{\hyperlink{classMatrix}{Matrix}} \&c, const \mbox{\hyperlink{classMatrix}{Matrix}} \&d, \mbox{\hyperlink{classMatrix}{Matrix}} \&tmp\+\_\+f, \mbox{\hyperlink{classMatrix}{Matrix}} \&tmp\+\_\+l, \mbox{\hyperlink{classMatrix}{Matrix}} \&v\+\_\+result)
\end{DoxyCompactItemize}
\textbf{ }\par
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \mbox{\hyperlink{Linear__algebra_8hpp_ac1628fdfaebf401b1cbc5116540ba779}{operator$\ast$}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&matrix, const double \&scalar)
\begin{DoxyCompactList}\small\item\em This operator takes a double scalar and a matrix as its operands. It returns a new gsl\+\_\+matrix$\ast$ that is the result of scaling the input matrix by the scalar. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \mbox{\hyperlink{Linear__algebra_8hpp_a64c608ba3c31fd9088fd759188ae2c1a}{operator$\ast$}} (const double \&scalar, const \mbox{\hyperlink{classMatrix}{Matrix}} \&matrix)
\end{DoxyCompactItemize}

\textbf{ }\par
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \mbox{\hyperlink{Linear__algebra_8hpp_a24da5fd1a21f5010ee32de71af9be3b9}{operator$\ast$}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2)
\begin{DoxyCompactList}\small\item\em This implementation checks that the matrices have compatible dimensions for multiplication and uses the BLAS library to perform the matrix multiplication. The result is stored in a newly allocated matrix result, which is then returned. The temporary memory is not freed here, and it is the responsibility of the caller to free the memory once the result is no longer needed. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMatrix}{Matrix}} \mbox{\hyperlink{Linear__algebra_8hpp_aed5a7001ababed63208a5f37d4da8a6e}{dot}} (const \mbox{\hyperlink{classMatrix}{Matrix}} \&m1, const \mbox{\hyperlink{classMatrix}{Matrix}} \&m2)
\end{DoxyCompactItemize}



\doxysubsection{Detailed Description}
This file serves as an interface for implementing any linear algebra engine for the continuum membrane model.

The code here defines a \mbox{\hyperlink{classMatrix}{Matrix}} class that uses the GNU Scientific Library (GSL) to implement various linear algebra operations. The class has four constructors\+:

\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000001}{Todo}}]benchmark -\/ In this case, if my matrices are small (\texorpdfstring{$<$}{<} 12 $\ast$ 3), but I need to repeat these matrices calculation for a large number of times, is gsl\+\_\+blas\+\_\+dgemm still more eifficent?\end{DoxyRefDesc}


For small matrices like the ones you\textquotesingle{}ve described, it\textquotesingle{}s possible that an element-\/wise implementation could be faster than using gsl\+\_\+blas\+\_\+dgemm() due to the overhead associated with setting up the function call and memory management. However, this depends on the context in which the function is being used and the specific hardware being used.

If the calculation of these small matrices is being repeated a large number of times, then the overhead of setting up the function call and memory management might be amortized over multiple calculations, making gsl\+\_\+blas\+\_\+dgemm() more efficient.

Ultimately, the best approach would be to benchmark both implementations (element-\/wise and using gsl\+\_\+blas\+\_\+dgemm() on your specific system and compare their performance for your use case.

-\/Chat\+GPT

\begin{DoxyDate}{Date}
2023-\/03-\/20
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
Copyright (c) 2023 
\end{DoxyCopyright}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{Linear__algebra_8hpp_a2f238a65f9bad9ee75cd16eeae374eda}\label{Linear__algebra_8hpp_a2f238a65f9bad9ee75cd16eeae374eda}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!a\_cross\_b\_plus\_c\_cross\_d@{a\_cross\_b\_plus\_c\_cross\_d}}
\index{a\_cross\_b\_plus\_c\_cross\_d@{a\_cross\_b\_plus\_c\_cross\_d}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{a\_cross\_b\_plus\_c\_cross\_d()}{a\_cross\_b\_plus\_c\_cross\_d()}}
{\footnotesize\ttfamily void a\+\_\+cross\+\_\+b\+\_\+plus\+\_\+c\+\_\+cross\+\_\+d (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{a,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{b,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{c,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{d,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{tmp\+\_\+f,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{tmp\+\_\+l,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{v\+\_\+result }\end{DoxyParamCaption})}

Computes the sum of two cross products and stores the result in an output matrix.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a} & First input column matrix. \\
\hline
\mbox{\texttt{ in}}  & {\em b} & Second input column matrix. \\
\hline
\mbox{\texttt{ in}}  & {\em c} & Third input column matrix. \\
\hline
\mbox{\texttt{ in}}  & {\em d} & Fourth input column matrix. \\
\hline
\mbox{\texttt{ in,out}}  & {\em tmp\+\_\+f} & Temporary matrix for storing the first cross product. \\
\hline
\mbox{\texttt{ in,out}}  & {\em tmp\+\_\+l} & Temporary matrix for storing the second cross product. \\
\hline
\mbox{\texttt{ out}}  & {\em v\+\_\+result} & Output matrix to store the final result.\\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::invalid\+\_\+argument} & if the input matrices have incompatible dimensions. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{Linear__algebra_8hpp_a27119e610bb0a9292cc9f7ed26a4b173}\label{Linear__algebra_8hpp_a27119e610bb0a9292cc9f7ed26a4b173}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!addition@{addition}}
\index{addition@{addition}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{addition()}{addition()}}
{\footnotesize\ttfamily void addition (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{tmp }\end{DoxyParamCaption})}



Compute the element-\/wise addition of two matrices and store the result in a third matrix. 

This function computes the element-\/wise addition of two input matrices of equal dimensions and stores the result in a third matrix. All input matrices are assumed to be of type \mbox{\hyperlink{classMatrix}{Matrix}}, which internally contains a gsl\+\_\+matrix pointer for efficiency.


\begin{DoxyParams}{Parameters}
{\em m1} & The first input matrix. \\
\hline
{\em m2} & The second input matrix. \\
\hline
{\em tmp} & The output matrix to store the resulting sum.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
All input matrices must have the same dimensions.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The output matrix \textquotesingle{}tmp\textquotesingle{} contains the element-\/wise sum of \textquotesingle{}m1\textquotesingle{} and \textquotesingle{}m2\textquotesingle{}. 
\end{DoxyPostcond}
\mbox{\Hypertarget{Linear__algebra_8hpp_ae19df5533c4af952dfe47bb010b66646}\label{Linear__algebra_8hpp_ae19df5533c4af952dfe47bb010b66646}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!assign\_rowVec\_to\_colVec@{assign\_rowVec\_to\_colVec}}
\index{assign\_rowVec\_to\_colVec@{assign\_rowVec\_to\_colVec}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{assign\_rowVec\_to\_colVec()}{assign\_rowVec\_to\_colVec()}}
{\footnotesize\ttfamily void assign\+\_\+row\+Vec\+\_\+to\+\_\+col\+Vec (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{src\+Row\+Vec,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{dest\+Col\+Vec }\end{DoxyParamCaption})}

Copies the values in a row vector to a column vector.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em src\+Row\+Vec} & Row vector containing the values to be copied. \\
\hline
\mbox{\texttt{ in,out}}  & {\em dest\+Col\+Vec} & Column vector to receive the copied values.\\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::invalid\+\_\+argument} & if the input matrices have incompatible dimensions. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{Linear__algebra_8hpp_a71cbe43985593c79552d1e40002e5bbb}\label{Linear__algebra_8hpp_a71cbe43985593c79552d1e40002e5bbb}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!colvec\_matrix\_multiplication@{colvec\_matrix\_multiplication}}
\index{colvec\_matrix\_multiplication@{colvec\_matrix\_multiplication}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{colvec\_matrix\_multiplication()}{colvec\_matrix\_multiplication()}}
{\footnotesize\ttfamily void colvec\+\_\+matrix\+\_\+multiplication (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{v1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{tmp }\end{DoxyParamCaption})}



Multiply a row vector by a matrix and store the result in a row vector. 

This function multiplies a row vector with a matrix and stores the resulting product in another row vector. All input matrices are assumed to be of type \mbox{\hyperlink{classMatrix}{Matrix}}, which internally contains a gsl\+\_\+matrix pointer for efficiency.


\begin{DoxyParams}{Parameters}
{\em v1} & The input row vector to be multiplied. \\
\hline
{\em m1} & The input matrix. \\
\hline
{\em tmp} & The output row vector to store the resulting product.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The number of columns of \textquotesingle{}v1\textquotesingle{} must match the number of rows of \textquotesingle{}m1\textquotesingle{}, and the dimensions of \textquotesingle{}tmp\textquotesingle{} must match the number of columns of \textquotesingle{}m1\textquotesingle{}.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The output row vector \textquotesingle{}tmp\textquotesingle{} contains the product of the input row vector \textquotesingle{}v1\textquotesingle{} and the input matrix \textquotesingle{}m1\textquotesingle{}.
\end{DoxyPostcond}
\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000002}{Todo}}]benchmark -\/ In this case, if my matrices are small (\texorpdfstring{$<$}{<} 12 $\ast$ 3), but I need to repeat these matrices calculation for a large number of times, is gsl\+\_\+blas\+\_\+dgemm still more eifficent?\end{DoxyRefDesc}


For small matrices like the ones you\textquotesingle{}ve described, it\textquotesingle{}s possible that an element-\/wise implementation could be faster than using gsl\+\_\+blas\+\_\+dgemm() due to the overhead associated with setting up the function call and memory management. However, this depends on the context in which the function is being used and the specific hardware being used.

If the calculation of these small matrices is being repeated a large number of times, then the overhead of setting up the function call and memory management might be amortized over multiple calculations, making gsl\+\_\+blas\+\_\+dgemm() more efficient.

Ultimately, the best approach would be to benchmark both implementations (element-\/wise and using gsl\+\_\+blas\+\_\+dgemm() on your specific system and compare their performance for your use case. \mbox{\Hypertarget{Linear__algebra_8hpp_a91de41df159ee60f4eecc860c7089c9b}\label{Linear__algebra_8hpp_a91de41df159ee60f4eecc860c7089c9b}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!const\_division@{const\_division}}
\index{const\_division@{const\_division}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{const\_division()}{const\_division()}}
{\footnotesize\ttfamily void const\+\_\+division (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const double}]{num,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{tmp }\end{DoxyParamCaption})}



Divide a matrix by a constant and store the result in a second matrix. 

This function divides the elements of an input matrix by a scalar constant and stores the result in a second output matrix. All input matrices are assumed to be of type \mbox{\hyperlink{classMatrix}{Matrix}}.


\begin{DoxyParams}{Parameters}
{\em m1} & The input matrix to be divided. \\
\hline
{\em num} & The scalar constant to divide by. \\
\hline
{\em tmp} & The output matrix to store the resulting quotient.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The dimensions of \textquotesingle{}m1\textquotesingle{} and \textquotesingle{}tmp\textquotesingle{} must match.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The output matrix \textquotesingle{}tmp\textquotesingle{} contains the element-\/wise division of \textquotesingle{}m1\textquotesingle{} and \textquotesingle{}num\textquotesingle{}. 
\end{DoxyPostcond}
\mbox{\Hypertarget{Linear__algebra_8hpp_ae8380f2d0eae7bf33cdb07560747ea72}\label{Linear__algebra_8hpp_ae8380f2d0eae7bf33cdb07560747ea72}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!const\_multiplication@{const\_multiplication}}
\index{const\_multiplication@{const\_multiplication}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{const\_multiplication()}{const\_multiplication()}}
{\footnotesize\ttfamily void const\+\_\+multiplication (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const double}]{num,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{tmp }\end{DoxyParamCaption})}



Multiply a matrix by a constant and store the result in a second matrix. 

This function multiplies the elements of an input matrix with a scalar constant and stores the result in a second output matrix. All input matrices are assumed to be of type \mbox{\hyperlink{classMatrix}{Matrix}}


\begin{DoxyParams}{Parameters}
{\em m1} & The input matrix to be multiplied. \\
\hline
{\em num} & The scalar constant to multiply with. \\
\hline
{\em tmp} & The output matrix to store the resulting product.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The dimensions of \textquotesingle{}m1\textquotesingle{} and \textquotesingle{}tmp\textquotesingle{} must match.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The output matrix \textquotesingle{}tmp\textquotesingle{} contains the element-\/wise multiplication of \textquotesingle{}m1\textquotesingle{} and \textquotesingle{}num\textquotesingle{}. 
\end{DoxyPostcond}
\mbox{\Hypertarget{Linear__algebra_8hpp_aa61de292b027fd1d36cd57eb8a679c65}\label{Linear__algebra_8hpp_aa61de292b027fd1d36cd57eb8a679c65}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!cross@{cross}}
\index{cross@{cross}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{cross()}{cross()}}
{\footnotesize\ttfamily void cross (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{temp }\end{DoxyParamCaption})}



Compute the cross product of two 3D vectors represented as 3x1 matrices. 

This function computes the cross product of two input vectors, which are assumed to be 3x1 matrices. The result is stored in another 3x1 matrix passed in as an argument.


\begin{DoxyParams}{Parameters}
{\em m1} & The first input vector as a 3x1 matrix. \\
\hline
{\em m2} & The second input vector as a 3x1 matrix. \\
\hline
{\em temp} & The output matrix to store the resulting cross product.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
All input matrices must have 3 rows and 1 column.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The output matrix \textquotesingle{}temp\textquotesingle{} contains the cross product of \textquotesingle{}m1\textquotesingle{} and \textquotesingle{}m2\textquotesingle{}. 
\end{DoxyPostcond}
\mbox{\Hypertarget{Linear__algebra_8hpp_a74ef398ea342aaaa6bef5128e9bf15a8}\label{Linear__algebra_8hpp_a74ef398ea342aaaa6bef5128e9bf15a8}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!cross\_col@{cross\_col}}
\index{cross\_col@{cross\_col}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{cross\_col()}{cross\_col()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} cross\+\_\+col (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2 }\end{DoxyParamCaption})}



This implementation takes two column vectors as arguments and returns their cross product as a new column vector. 

\begin{DoxyNote}{Note}
Note that this implementation assumes that the input matrices are already column vectors, so no additional transposition is necessary. 
\end{DoxyNote}
\mbox{\Hypertarget{Linear__algebra_8hpp_a8c3bf9ef46fde8b009e48d735c668d93}\label{Linear__algebra_8hpp_a8c3bf9ef46fde8b009e48d735c668d93}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!cross\_row@{cross\_row}}
\index{cross\_row@{cross\_row}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{cross\_row()}{cross\_row()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} cross\+\_\+row (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2 }\end{DoxyParamCaption})}



This implementation takes two row vectors as arguments and returns their cross product as a new row vector. 

\begin{DoxyNote}{Note}
Note that this implementation assumes that the input matrices are already row vectors, so no additional transposition is necessary. 
\end{DoxyNote}
\mbox{\Hypertarget{Linear__algebra_8hpp_aed5a7001ababed63208a5f37d4da8a6e}\label{Linear__algebra_8hpp_aed5a7001ababed63208a5f37d4da8a6e}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!dot@{dot}}
\index{dot@{dot}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{dot()}{dot()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} dot (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2 }\end{DoxyParamCaption})}

\mbox{\Hypertarget{Linear__algebra_8hpp_a16f2d841a7bbc07c6ed264848e532536}\label{Linear__algebra_8hpp_a16f2d841a7bbc07c6ed264848e532536}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!dot\_col@{dot\_col}}
\index{dot\_col@{dot\_col}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{dot\_col()}{dot\_col()}}
{\footnotesize\ttfamily double dot\+\_\+col (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2 }\end{DoxyParamCaption})}



This implementation takes two column vectors as arguments and returns their dot product as double. 

\begin{DoxyNote}{Note}
Note that this implementation assumes that the input matrices are already column vectors, so no additional transposition is necessary. 
\end{DoxyNote}
\mbox{\Hypertarget{Linear__algebra_8hpp_a1321d248693d484c54370beae277e19d}\label{Linear__algebra_8hpp_a1321d248693d484c54370beae277e19d}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!dot\_row@{dot\_row}}
\index{dot\_row@{dot\_row}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{dot\_row()}{dot\_row()}}
{\footnotesize\ttfamily double dot\+\_\+row (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2 }\end{DoxyParamCaption})}



This implementation takes two row vectors as arguments and returns their dot product as double. 

\begin{DoxyNote}{Note}
Note that this implementation converts the row vectors into column vectors before computing the dot product. 
\end{DoxyNote}
\mbox{\Hypertarget{Linear__algebra_8hpp_a4baa40e609ed63be814718a4b8dd2f56}\label{Linear__algebra_8hpp_a4baa40e609ed63be814718a4b8dd2f56}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!get\_unit\_vector@{get\_unit\_vector}}
\index{get\_unit\_vector@{get\_unit\_vector}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{get\_unit\_vector()}{get\_unit\_vector()}}
{\footnotesize\ttfamily void get\+\_\+unit\+\_\+vector (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m\+\_\+unit }\end{DoxyParamCaption})}



Get the unit vector in the direction of m1 which is a (3, 1) \mbox{\hyperlink{classMatrix}{Matrix}}. 

This function computes the unit vector in the direction of a given input vector, which is assumed to be a 3x1 matrix. The result is stored in another 3x1 matrix.


\begin{DoxyParams}{Parameters}
{\em m1} & The input vector to compute the unit vector of. \\
\hline
{\em m\+\_\+unit} & The output matrix to store the resulting unit vector.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The input matrix \textquotesingle{}m1\textquotesingle{} must be a 3x1 matrix.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The output matrix \textquotesingle{}m\+\_\+unit\textquotesingle{} contains the unit vector in the direction of \textquotesingle{}m1\textquotesingle{}. 
\end{DoxyPostcond}
\mbox{\Hypertarget{Linear__algebra_8hpp_a476d951514d654f916418cee7d5b189f}\label{Linear__algebra_8hpp_a476d951514d654f916418cee7d5b189f}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!kron@{kron}}
\index{kron@{kron}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{kron()}{kron()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} kron (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{v1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{v2 }\end{DoxyParamCaption})}



the Kronecker product between two column matrices and returns the result in an output matrix. The Kronecker product is defined as follows\+: 

\begin{DoxyVerb}kron(v1, v2) = [v1(1)*v2(1)  v1(1)*v2(2)  ...  v1(1)*v2(n2)
                v1(2)*v2(1)  v1(2)*v2(2)  ...  v1(2)*v2(n2)
                ...          ...          ...  ...
                v1(n1)*v2(1)  v1(n1)*v2(2)  ...  v1(n1)*v2(n2)]
\end{DoxyVerb}
 where v1 and v2 are column matrices of size n1 and n2 respectively, and the output matrix has size n1$\ast$n2 x n1$\ast$n2.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em v1} & First input column matrix. \\
\hline
\mbox{\texttt{ in}}  & {\em v2} & Second input column matrix. \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Deprecated}
\item[\mbox{\hyperlink{deprecated__deprecated000002}{Deprecated}}]Might cause memory leak! \end{DoxyRefDesc}
\begin{DoxyReturn}{Returns}
Output matrix to store the result.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::invalid\+\_\+argument} & if the output matrix has incompatible dimensions. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{Linear__algebra_8hpp_ae0131af41656cb51262343c655b461a4}\label{Linear__algebra_8hpp_ae0131af41656cb51262343c655b461a4}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!kron@{kron}}
\index{kron@{kron}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{kron()}{kron()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} kron (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{v1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{v2,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m\+\_\+result }\end{DoxyParamCaption})}



the Kronecker product between two column matrices and returns the result in an output matrix. The Kronecker product is defined as follows\+: 

\begin{DoxyVerb}kron(v1, v2) = [v1(1)*v2(1)  v1(1)*v2(2)  ...  v1(1)*v2(n2)
                v1(2)*v2(1)  v1(2)*v2(2)  ...  v1(2)*v2(n2)
                ...          ...          ...  ...
                v1(n1)*v2(1)  v1(n1)*v2(2)  ...  v1(n1)*v2(n2)]
\end{DoxyVerb}
 where v1 and v2 are column matrices of size n1 and n2 respectively, and the output matrix has size n1$\ast$n2 x n1$\ast$n2.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em v1} & First input column matrix. \\
\hline
\mbox{\texttt{ in}}  & {\em v2} & Second input column matrix. \\
\hline
\mbox{\texttt{ out}}  & {\em m\+\_\+result} & Output matrix to store the result. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{Linear__algebra_8hpp_af45abfc5a0e5e23d8aabcea64c339312}\label{Linear__algebra_8hpp_af45abfc5a0e5e23d8aabcea64c339312}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!mat\_calloc@{mat\_calloc}}
\index{mat\_calloc@{mat\_calloc}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{mat\_calloc()}{mat\_calloc()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} mat\+\_\+calloc (\begin{DoxyParamCaption}\item[{const int \&}]{nrow,  }\item[{const int \&}]{ncol }\end{DoxyParamCaption})}



This function allocates a new \mbox{\hyperlink{classMatrix}{Matrix}} object with the specified number of rows and columns, and initializes all elements to zero. 


\begin{DoxyParams}{Parameters}
{\em nrow} & \\
\hline
{\em ncol} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classMatrix}{Matrix}} 
\end{DoxyReturn}
\mbox{\Hypertarget{Linear__algebra_8hpp_a7babd9d5d81db0f04b3e8fccc0ca0e76}\label{Linear__algebra_8hpp_a7babd9d5d81db0f04b3e8fccc0ca0e76}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!multiplication@{multiplication}}
\index{multiplication@{multiplication}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{multiplication()}{multiplication()}}
{\footnotesize\ttfamily void multiplication (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{tmp }\end{DoxyParamCaption})}



Multiply a matrix by a constant and store the result in a second matrix. 

This function multiplies the elements of an input matrix with a scalar constant and stores the result in a second output matrix. All input matrices are assumed to be of type \mbox{\hyperlink{classMatrix}{Matrix}}


\begin{DoxyParams}{Parameters}
{\em m1} & The input matrix to be multiplied. \\
\hline
{\em num} & The scalar constant to multiply with. \\
\hline
{\em tmp} & The output matrix to store the resulting product.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The dimensions of \textquotesingle{}m1\textquotesingle{} and \textquotesingle{}tmp\textquotesingle{} must match.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The output matrix \textquotesingle{}tmp\textquotesingle{} contains the element-\/wise multiplication of \textquotesingle{}m1\textquotesingle{} and \textquotesingle{}num\textquotesingle{}. 
\end{DoxyPostcond}
\mbox{\Hypertarget{Linear__algebra_8hpp_ae5fa66935b125fb2613ffe2ce57e935f}\label{Linear__algebra_8hpp_ae5fa66935b125fb2613ffe2ce57e935f}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!negative@{negative}}
\index{negative@{negative}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{negative()}{negative()}}
{\footnotesize\ttfamily void negative (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m\+\_\+neg }\end{DoxyParamCaption})}



Computes the negative of a given matrix. 

This function computes the element-\/wise negative of a given matrix and stores the result in another matrix. Element-\/wise negative is defined as multiplying each element of the matrix with -\/1. The input matrix \textquotesingle{}m1\textquotesingle{} is not modified by this function.


\begin{DoxyParams}{Parameters}
{\em m1} & The matrix to compute the negative of. \\
\hline
{\em m\+\_\+neg} & The matrix to store the result in.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Both matrices \textquotesingle{}m1\textquotesingle{} and \textquotesingle{}m\+\_\+neg\textquotesingle{} must have been allocated memory and initialized properly. 

Both matrices \textquotesingle{}m1\textquotesingle{} and \textquotesingle{}m\+\_\+neg\textquotesingle{} must have the same dimensions.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The matrix \textquotesingle{}m\+\_\+neg\textquotesingle{} contains the element-\/wise negative of \textquotesingle{}m1\textquotesingle{}. 
\end{DoxyPostcond}
\mbox{\Hypertarget{Linear__algebra_8hpp_a64c608ba3c31fd9088fd759188ae2c1a}\label{Linear__algebra_8hpp_a64c608ba3c31fd9088fd759188ae2c1a}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{operator$\ast$()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} operator$\ast$ (\begin{DoxyParamCaption}\item[{const double \&}]{scalar,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{matrix }\end{DoxyParamCaption})}

\mbox{\Hypertarget{Linear__algebra_8hpp_a24da5fd1a21f5010ee32de71af9be3b9}\label{Linear__algebra_8hpp_a24da5fd1a21f5010ee32de71af9be3b9}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{operator$\ast$()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} operator$\ast$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2 }\end{DoxyParamCaption})}



This implementation checks that the matrices have compatible dimensions for multiplication and uses the BLAS library to perform the matrix multiplication. The result is stored in a newly allocated matrix result, which is then returned. The temporary memory is not freed here, and it is the responsibility of the caller to free the memory once the result is no longer needed. 


\begin{DoxyParams}{Parameters}
{\em m1} & \\
\hline
{\em m2} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classMatrix}{Matrix}} 
\end{DoxyReturn}
\mbox{\Hypertarget{Linear__algebra_8hpp_ac1628fdfaebf401b1cbc5116540ba779}\label{Linear__algebra_8hpp_ac1628fdfaebf401b1cbc5116540ba779}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{operator$\ast$()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} operator$\ast$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{matrix,  }\item[{const double \&}]{scalar }\end{DoxyParamCaption})}



This operator takes a double scalar and a matrix as its operands. It returns a new gsl\+\_\+matrix$\ast$ that is the result of scaling the input matrix by the scalar. 


\begin{DoxyParams}{Parameters}
{\em scalar} & \\
\hline
{\em matrix} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classMatrix}{Matrix}} 
\end{DoxyReturn}
\mbox{\Hypertarget{Linear__algebra_8hpp_a3fdf5f190807099ee79e068f83eb517e}\label{Linear__algebra_8hpp_a3fdf5f190807099ee79e068f83eb517e}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!operator$\ast$=@{operator$\ast$=}}
\index{operator$\ast$=@{operator$\ast$=}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{operator$\ast$=()}{operator*=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} \& operator$\ast$= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{mat,  }\item[{const double \&}]{scalar }\end{DoxyParamCaption})}



This implementation uses the gsl\+\_\+matrix\+\_\+scale function to scale each element in the matrix by the scalar value. The function returns the modified matrix, which allows for method chaining when using the $\ast$= operator. 


\begin{DoxyParams}{Parameters}
{\em mat} & \\
\hline
{\em scalar} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classMatrix}{Matrix}} 
\end{DoxyReturn}
\mbox{\Hypertarget{Linear__algebra_8hpp_a4a0a835103a72d65a8d4038c34d4a773}\label{Linear__algebra_8hpp_a4a0a835103a72d65a8d4038c34d4a773}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!operator$\ast$=@{operator$\ast$=}}
\index{operator$\ast$=@{operator$\ast$=}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{operator$\ast$=()}{operator*=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} \& operator$\ast$= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMatrix}{Matrix}}}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2 }\end{DoxyParamCaption})}



This implementation checks that the matrices have compatible dimensions for multiplication and uses the BLAS library to perform the matrix multiplication. The result is stored in a temporary matrix, which is then copied back into m1. Finally, the temporary memory is freed before returning m1. 


\begin{DoxyParams}{Parameters}
{\em m1} & \\
\hline
{\em m2} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classMatrix}{Matrix}} 
\end{DoxyReturn}
\mbox{\Hypertarget{Linear__algebra_8hpp_aa5a9f2db2b3c1862c9c0d19241239ce7}\label{Linear__algebra_8hpp_aa5a9f2db2b3c1862c9c0d19241239ce7}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!operator+@{operator+}}
\index{operator+@{operator+}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{operator+()}{operator+()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} operator+ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2 }\end{DoxyParamCaption})}



This implementation checks that the matrices have the same dimensions and allocates memory for the result of the addition. It then adds the matrices element-\/wise and stores the result in a newly allocated matrix result, which is then returned. 

\mbox{\Hypertarget{Linear__algebra_8hpp_a2d1976903224767c788b0f3e5846bd6c}\label{Linear__algebra_8hpp_a2d1976903224767c788b0f3e5846bd6c}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{operator+=()}{operator+=()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} \& operator+= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2 }\end{DoxyParamCaption})}



This implementation takes two gsl\+\_\+matrix pointers as arguments and adds the elements of the second matrix to the first matrix. It first checks that the matrices have the same dimensions, and throws an exception if they do not. Then it iterates over the elements of the matrices and adds the corresponding elements. Finally, it returns a pointer to the modified first matrix. Note that this implementation modifies the first matrix in place, rather than creating a new matrix. If you want to create a new matrix instead, you could modify the implementation accordingly. 

\mbox{\Hypertarget{Linear__algebra_8hpp_a52ad5ef4b9998529c85e8523c20d6b86}\label{Linear__algebra_8hpp_a52ad5ef4b9998529c85e8523c20d6b86}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{operator-\/()}{operator-()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} operator-\/ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2 }\end{DoxyParamCaption})}



This implementation checks that the matrices have the same dimensions and allocates memory for the result of the subtraction. It then adds the matrices element-\/wise and stores the result in a newly allocated matrix result, which is then returned. 

\mbox{\Hypertarget{Linear__algebra_8hpp_a279fb974b0ba51b716f08f8f74417acc}\label{Linear__algebra_8hpp_a279fb974b0ba51b716f08f8f74417acc}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!operator-\/=@{operator-\/=}}
\index{operator-\/=@{operator-\/=}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{operator-\/=()}{operator-=()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} \& operator-\/= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2 }\end{DoxyParamCaption})}



This implementation takes two gsl\+\_\+matrix pointers as arguments and subtract the elements of the second matrix from the first matrix. It first checks that the matrices have the same dimensions, and throws an exception if they do not. Then it iterates over the elements of the matrices and adds the corresponding elements. Finally, it returns a pointer to the modified first matrix. Note that this implementation modifies the first matrix in place, rather than creating a new matrix. If you want to create a new matrix instead, you could modify the implementation accordingly. 

\mbox{\Hypertarget{Linear__algebra_8hpp_a287766f48ce1537b4789b890515572cb}\label{Linear__algebra_8hpp_a287766f48ce1537b4789b890515572cb}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!operator/@{operator/}}
\index{operator/@{operator/}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{operator/()}{operator/()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} operator/ (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMatrix}{Matrix}}}]{matrix,  }\item[{const double \&}]{scalar }\end{DoxyParamCaption})}



This operator takes a double scalar and a matrix as its operands. It returns a new gsl\+\_\+matrix$\ast$ that is the result of scaling the input matrix by 1/scalar. 


\begin{DoxyParams}{Parameters}
{\em scalar} & \\
\hline
{\em matrix} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classMatrix}{Matrix}} 
\end{DoxyReturn}
\mbox{\Hypertarget{Linear__algebra_8hpp_a4982f65adbc5a3f46660ba7eb704b3c4}\label{Linear__algebra_8hpp_a4982f65adbc5a3f46660ba7eb704b3c4}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!operator/=@{operator/=}}
\index{operator/=@{operator/=}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{operator/=()}{operator/=()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMatrix}{Matrix}} \& operator/= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{mat,  }\item[{const double \&}]{scalar }\end{DoxyParamCaption})}



This implementation uses the gsl\+\_\+matrix\+\_\+scale function to scale each element in the matrix by 1/the scalar value. The function returns the modified matrix, which allows for method chaining when using the $\ast$= operator. 


\begin{DoxyParams}{Parameters}
{\em mat} & \\
\hline
{\em scalar} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classMatrix}{Matrix}} 
\end{DoxyReturn}
\mbox{\Hypertarget{Linear__algebra_8hpp_a391be9262318fa95cf1c7c21d0afa0f9}\label{Linear__algebra_8hpp_a391be9262318fa95cf1c7c21d0afa0f9}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}}
{\footnotesize\ttfamily std\+::ostream \& operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{stream,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{matrix }\end{DoxyParamCaption})}



Bit push all element of a matrix in the format of\+: 

a11, a12, a13, ..., a21, a22, a23, ..., ...,


\begin{DoxyParams}{Parameters}
{\em stream} & ostream \\
\hline
{\em matrix} & matrix to be output as string \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::ostream\& 
\end{DoxyReturn}
\mbox{\Hypertarget{Linear__algebra_8hpp_a16c686d2f9ed45866109caffe69b246b}\label{Linear__algebra_8hpp_a16c686d2f9ed45866109caffe69b246b}} 
\index{Linear\_algebra.hpp@{Linear\_algebra.hpp}!subtraction@{subtraction}}
\index{subtraction@{subtraction}!Linear\_algebra.hpp@{Linear\_algebra.hpp}}
\doxysubsubsection{\texorpdfstring{subtraction()}{subtraction()}}
{\footnotesize\ttfamily void subtraction (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m1,  }\item[{const \mbox{\hyperlink{classMatrix}{Matrix}} \&}]{m2,  }\item[{\mbox{\hyperlink{classMatrix}{Matrix}} \&}]{tmp }\end{DoxyParamCaption})}



Compute the element-\/wise subtraction of two matrices and store the result in a third matrix. 

This function computes the element-\/wise subtraction of two input matrices of equal dimensions and stores the result in a third matrix. All input matrices are assumed to be of type \mbox{\hyperlink{classMatrix}{Matrix}}, which internally contains a gsl\+\_\+matrix pointer for efficiency.


\begin{DoxyParams}{Parameters}
{\em m1} & The first input matrix. \\
\hline
{\em m2} & The second input matrix. \\
\hline
{\em tmp} & The output matrix to store the resulting difference.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
All input matrices must have the same dimensions.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The output matrix \textquotesingle{}tmp\textquotesingle{} contains the element-\/wise difference of \textquotesingle{}m1\textquotesingle{} and \textquotesingle{}m2\textquotesingle{}. 
\end{DoxyPostcond}
