<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Continuum Membrane: include/Linear_algebra.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Continuum Membrane
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Linear_algebra.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;vector&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;gsl/gsl_matrix.h&gt;</code><br />
<code>#include &lt;gsl/gsl_blas.h&gt;</code><br />
<code>#include &lt;gsl/gsl_linalg.h&gt;</code><br />
</div>
<p><a href="Linear__algebra_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> used in continuum membrane model.  <a href="classMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af45abfc5a0e5e23d8aabcea64c339312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#af45abfc5a0e5e23d8aabcea64c339312">mat_calloc</a> (const int &amp;nrow, const int &amp;ncol)</td></tr>
<tr class="memdesc:af45abfc5a0e5e23d8aabcea64c339312"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates a new <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> object with the specified number of rows and columns, and initializes all elements to zero.  <br /></td></tr>
<tr class="separator:af45abfc5a0e5e23d8aabcea64c339312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391be9262318fa95cf1c7c21d0afa0f9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a391be9262318fa95cf1c7c21d0afa0f9">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classMatrix.html">Matrix</a> &amp;matrix)</td></tr>
<tr class="memdesc:a391be9262318fa95cf1c7c21d0afa0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit push all element of a matrix in the format of:  <br /></td></tr>
<tr class="separator:a391be9262318fa95cf1c7c21d0afa0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1976903224767c788b0f3e5846bd6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a2d1976903224767c788b0f3e5846bd6c">operator+=</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:a2d1976903224767c788b0f3e5846bd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation takes two gsl_matrix pointers as arguments and adds the elements of the second matrix to the first matrix. It first checks that the matrices have the same dimensions, and throws an exception if they do not. Then it iterates over the elements of the matrices and adds the corresponding elements. Finally, it returns a pointer to the modified first matrix. Note that this implementation modifies the first matrix in place, rather than creating a new matrix. If you want to create a new matrix instead, you could modify the implementation accordingly.  <br /></td></tr>
<tr class="separator:a2d1976903224767c788b0f3e5846bd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a9f2db2b3c1862c9c0d19241239ce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#aa5a9f2db2b3c1862c9c0d19241239ce7">operator+</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:aa5a9f2db2b3c1862c9c0d19241239ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation checks that the matrices have the same dimensions and allocates memory for the result of the addition. It then adds the matrices element-wise and stores the result in a newly allocated matrix result, which is then returned.  <br /></td></tr>
<tr class="separator:aa5a9f2db2b3c1862c9c0d19241239ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279fb974b0ba51b716f08f8f74417acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a279fb974b0ba51b716f08f8f74417acc">operator-=</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:a279fb974b0ba51b716f08f8f74417acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation takes two gsl_matrix pointers as arguments and subtract the elements of the second matrix from the first matrix. It first checks that the matrices have the same dimensions, and throws an exception if they do not. Then it iterates over the elements of the matrices and adds the corresponding elements. Finally, it returns a pointer to the modified first matrix. Note that this implementation modifies the first matrix in place, rather than creating a new matrix. If you want to create a new matrix instead, you could modify the implementation accordingly.  <br /></td></tr>
<tr class="separator:a279fb974b0ba51b716f08f8f74417acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ad5ef4b9998529c85e8523c20d6b86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a52ad5ef4b9998529c85e8523c20d6b86">operator-</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:a52ad5ef4b9998529c85e8523c20d6b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation checks that the matrices have the same dimensions and allocates memory for the result of the subtraction. It then adds the matrices element-wise and stores the result in a newly allocated matrix result, which is then returned.  <br /></td></tr>
<tr class="separator:a52ad5ef4b9998529c85e8523c20d6b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdf5f190807099ee79e068f83eb517e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a3fdf5f190807099ee79e068f83eb517e">operator*=</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;mat, const double &amp;scalar)</td></tr>
<tr class="memdesc:a3fdf5f190807099ee79e068f83eb517e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation uses the gsl_matrix_scale function to scale each element in the matrix by the scalar value. The function returns the modified matrix, which allows for method chaining when using the *= operator.  <br /></td></tr>
<tr class="separator:a3fdf5f190807099ee79e068f83eb517e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0a835103a72d65a8d4038c34d4a773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a4a0a835103a72d65a8d4038c34d4a773">operator*=</a> (<a class="el" href="classMatrix.html">Matrix</a> m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:a4a0a835103a72d65a8d4038c34d4a773"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation checks that the matrices have compatible dimensions for multiplication and uses the BLAS library to perform the matrix multiplication. The result is stored in a temporary matrix, which is then copied back into m1. Finally, the temporary memory is freed before returning m1.  <br /></td></tr>
<tr class="separator:a4a0a835103a72d65a8d4038c34d4a773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4982f65adbc5a3f46660ba7eb704b3c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a4982f65adbc5a3f46660ba7eb704b3c4">operator/=</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;mat, const double &amp;scalar)</td></tr>
<tr class="memdesc:a4982f65adbc5a3f46660ba7eb704b3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation uses the gsl_matrix_scale function to scale each element in the matrix by 1/the scalar value. The function returns the modified matrix, which allows for method chaining when using the *= operator.  <br /></td></tr>
<tr class="separator:a4982f65adbc5a3f46660ba7eb704b3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287766f48ce1537b4789b890515572cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a287766f48ce1537b4789b890515572cb">operator/</a> (<a class="el" href="classMatrix.html">Matrix</a> matrix, const double &amp;scalar)</td></tr>
<tr class="memdesc:a287766f48ce1537b4789b890515572cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator takes a double scalar and a matrix as its operands. It returns a new gsl_matrix* that is the result of scaling the input matrix by 1/scalar.  <br /></td></tr>
<tr class="separator:a287766f48ce1537b4789b890515572cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f2d841a7bbc07c6ed264848e532536"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a16f2d841a7bbc07c6ed264848e532536">dot_col</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:a16f2d841a7bbc07c6ed264848e532536"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation takes two column vectors as arguments and returns their dot product as double.  <br /></td></tr>
<tr class="separator:a16f2d841a7bbc07c6ed264848e532536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1321d248693d484c54370beae277e19d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a1321d248693d484c54370beae277e19d">dot_row</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:a1321d248693d484c54370beae277e19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation takes two row vectors as arguments and returns their dot product as double.  <br /></td></tr>
<tr class="separator:a1321d248693d484c54370beae277e19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ef398ea342aaaa6bef5128e9bf15a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a74ef398ea342aaaa6bef5128e9bf15a8">cross_col</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:a74ef398ea342aaaa6bef5128e9bf15a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation takes two column vectors as arguments and returns their cross product as a new column vector.  <br /></td></tr>
<tr class="separator:a74ef398ea342aaaa6bef5128e9bf15a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3bf9ef46fde8b009e48d735c668d93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a8c3bf9ef46fde8b009e48d735c668d93">cross_row</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:a8c3bf9ef46fde8b009e48d735c668d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation takes two row vectors as arguments and returns their cross product as a new row vector.  <br /></td></tr>
<tr class="separator:a8c3bf9ef46fde8b009e48d735c668d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fa66935b125fb2613ffe2ce57e935f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#ae5fa66935b125fb2613ffe2ce57e935f">negative</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, <a class="el" href="classMatrix.html">Matrix</a> &amp;m_neg)</td></tr>
<tr class="memdesc:ae5fa66935b125fb2613ffe2ce57e935f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the negative of a given matrix.  <br /></td></tr>
<tr class="separator:ae5fa66935b125fb2613ffe2ce57e935f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4baa40e609ed63be814718a4b8dd2f56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a4baa40e609ed63be814718a4b8dd2f56">get_unit_vector</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, <a class="el" href="classMatrix.html">Matrix</a> &amp;m_unit)</td></tr>
<tr class="memdesc:a4baa40e609ed63be814718a4b8dd2f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unit vector in the direction of m1 which is a (3, 1) <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a>.  <br /></td></tr>
<tr class="separator:a4baa40e609ed63be814718a4b8dd2f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61de292b027fd1d36cd57eb8a679c65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#aa61de292b027fd1d36cd57eb8a679c65">cross</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2, <a class="el" href="classMatrix.html">Matrix</a> &amp;temp)</td></tr>
<tr class="memdesc:aa61de292b027fd1d36cd57eb8a679c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cross product of two 3D vectors represented as 3x1 matrices.  <br /></td></tr>
<tr class="separator:aa61de292b027fd1d36cd57eb8a679c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27119e610bb0a9292cc9f7ed26a4b173"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a27119e610bb0a9292cc9f7ed26a4b173">addition</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2, <a class="el" href="classMatrix.html">Matrix</a> &amp;tmp)</td></tr>
<tr class="memdesc:a27119e610bb0a9292cc9f7ed26a4b173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the element-wise addition of two matrices and store the result in a third matrix.  <br /></td></tr>
<tr class="separator:a27119e610bb0a9292cc9f7ed26a4b173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c686d2f9ed45866109caffe69b246b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a16c686d2f9ed45866109caffe69b246b">subtraction</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2, <a class="el" href="classMatrix.html">Matrix</a> &amp;tmp)</td></tr>
<tr class="memdesc:a16c686d2f9ed45866109caffe69b246b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the element-wise subtraction of two matrices and store the result in a third matrix.  <br /></td></tr>
<tr class="separator:a16c686d2f9ed45866109caffe69b246b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7babd9d5d81db0f04b3e8fccc0ca0e76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a7babd9d5d81db0f04b3e8fccc0ca0e76">multiplication</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2, <a class="el" href="classMatrix.html">Matrix</a> &amp;tmp)</td></tr>
<tr class="memdesc:a7babd9d5d81db0f04b3e8fccc0ca0e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a matrix by a constant and store the result in a second matrix.  <br /></td></tr>
<tr class="separator:a7babd9d5d81db0f04b3e8fccc0ca0e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8380f2d0eae7bf33cdb07560747ea72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#ae8380f2d0eae7bf33cdb07560747ea72">const_multiplication</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const double num, <a class="el" href="classMatrix.html">Matrix</a> &amp;tmp)</td></tr>
<tr class="memdesc:ae8380f2d0eae7bf33cdb07560747ea72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a matrix by a constant and store the result in a second matrix.  <br /></td></tr>
<tr class="separator:ae8380f2d0eae7bf33cdb07560747ea72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91de41df159ee60f4eecc860c7089c9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a91de41df159ee60f4eecc860c7089c9b">const_division</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const double num, <a class="el" href="classMatrix.html">Matrix</a> &amp;tmp)</td></tr>
<tr class="memdesc:a91de41df159ee60f4eecc860c7089c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a matrix by a constant and store the result in a second matrix.  <br /></td></tr>
<tr class="separator:a91de41df159ee60f4eecc860c7089c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cbe43985593c79552d1e40002e5bbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a71cbe43985593c79552d1e40002e5bbb">colvec_matrix_multiplication</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;v1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, <a class="el" href="classMatrix.html">Matrix</a> &amp;tmp)</td></tr>
<tr class="memdesc:a71cbe43985593c79552d1e40002e5bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a row vector by a matrix and store the result in a row vector.  <br /></td></tr>
<tr class="separator:a71cbe43985593c79552d1e40002e5bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476d951514d654f916418cee7d5b189f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a476d951514d654f916418cee7d5b189f">kron</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;v1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;v2)</td></tr>
<tr class="memdesc:a476d951514d654f916418cee7d5b189f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the Kronecker product between two column matrices and returns the result in an output matrix. The Kronecker product is defined as follows:  <br /></td></tr>
<tr class="separator:a476d951514d654f916418cee7d5b189f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0131af41656cb51262343c655b461a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#ae0131af41656cb51262343c655b461a4">kron</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;v1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;v2, <a class="el" href="classMatrix.html">Matrix</a> &amp;m_result)</td></tr>
<tr class="memdesc:ae0131af41656cb51262343c655b461a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">the Kronecker product between two column matrices and returns the result in an output matrix. The Kronecker product is defined as follows:  <br /></td></tr>
<tr class="separator:ae0131af41656cb51262343c655b461a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19df5533c4af952dfe47bb010b66646"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#ae19df5533c4af952dfe47bb010b66646">assign_rowVec_to_colVec</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;srcRowVec, <a class="el" href="classMatrix.html">Matrix</a> &amp;destColVec)</td></tr>
<tr class="separator:ae19df5533c4af952dfe47bb010b66646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f238a65f9bad9ee75cd16eeae374eda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a2f238a65f9bad9ee75cd16eeae374eda">a_cross_b_plus_c_cross_d</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;a, const <a class="el" href="classMatrix.html">Matrix</a> &amp;b, const <a class="el" href="classMatrix.html">Matrix</a> &amp;c, const <a class="el" href="classMatrix.html">Matrix</a> &amp;d, <a class="el" href="classMatrix.html">Matrix</a> &amp;tmp_f, <a class="el" href="classMatrix.html">Matrix</a> &amp;tmp_l, <a class="el" href="classMatrix.html">Matrix</a> &amp;v_result)</td></tr>
<tr class="separator:a2f238a65f9bad9ee75cd16eeae374eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac1628fdfaebf401b1cbc5116540ba779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#ac1628fdfaebf401b1cbc5116540ba779">operator*</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;matrix, const double &amp;scalar)</td></tr>
<tr class="memdesc:ac1628fdfaebf401b1cbc5116540ba779"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator takes a double scalar and a matrix as its operands. It returns a new gsl_matrix* that is the result of scaling the input matrix by the scalar.  <br /></td></tr>
<tr class="separator:ac1628fdfaebf401b1cbc5116540ba779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c608ba3c31fd9088fd759188ae2c1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a64c608ba3c31fd9088fd759188ae2c1a">operator*</a> (const double &amp;scalar, const <a class="el" href="classMatrix.html">Matrix</a> &amp;matrix)</td></tr>
<tr class="separator:a64c608ba3c31fd9088fd759188ae2c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a24da5fd1a21f5010ee32de71af9be3b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#a24da5fd1a21f5010ee32de71af9be3b9">operator*</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:a24da5fd1a21f5010ee32de71af9be3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation checks that the matrices have compatible dimensions for multiplication and uses the BLAS library to perform the matrix multiplication. The result is stored in a newly allocated matrix result, which is then returned. The temporary memory is not freed here, and it is the responsibility of the caller to free the memory once the result is no longer needed.  <br /></td></tr>
<tr class="separator:a24da5fd1a21f5010ee32de71af9be3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5a7001ababed63208a5f37d4da8a6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Linear__algebra_8hpp.html#aed5a7001ababed63208a5f37d4da8a6e">dot</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="separator:aed5a7001ababed63208a5f37d4da8a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file serves as an interface for implementing any linear algebra engine for the continuum membrane model.</p>
<p>The code here defines a <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> class that uses the GNU Scientific Library (GSL) to implement various linear algebra operations. The class has four constructors:</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>benchmark - In this case, if my matrices are small (&lt; 12 * 3), but I need to repeat these matrices calculation for a large number of times, is gsl_blas_dgemm still more eifficent?</dd></dl>
<p>For small matrices like the ones you've described, it's possible that an element-wise implementation could be faster than using gsl_blas_dgemm() due to the overhead associated with setting up the function call and memory management. However, this depends on the context in which the function is being used and the specific hardware being used.</p>
<p>If the calculation of these small matrices is being repeated a large number of times, then the overhead of setting up the function call and memory management might be amortized over multiple calculations, making gsl_blas_dgemm() more efficient.</p>
<p>Ultimately, the best approach would be to benchmark both implementations (element-wise and using gsl_blas_dgemm() on your specific system and compare their performance for your use case.</p>
<p>-ChatGPT</p>
<dl class="section date"><dt>Date</dt><dd>2023-03-20</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2023 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2f238a65f9bad9ee75cd16eeae374eda" name="a2f238a65f9bad9ee75cd16eeae374eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f238a65f9bad9ee75cd16eeae374eda">&#9670;&#160;</a></span>a_cross_b_plus_c_cross_d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void a_cross_b_plus_c_cross_d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>tmp_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>tmp_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>v_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the sum of two cross products and stores the result in an output matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First input column matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second input column matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Third input column matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>Fourth input column matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tmp_f</td><td>Temporary matrix for storing the first cross product. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tmp_l</td><td>Temporary matrix for storing the second cross product. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v_result</td><td>Output matrix to store the final result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the input matrices have incompatible dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27119e610bb0a9292cc9f7ed26a4b173" name="a27119e610bb0a9292cc9f7ed26a4b173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27119e610bb0a9292cc9f7ed26a4b173">&#9670;&#160;</a></span>addition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the element-wise addition of two matrices and store the result in a third matrix. </p>
<p>This function computes the element-wise addition of two input matrices of equal dimensions and stores the result in a third matrix. All input matrices are assumed to be of type <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a>, which internally contains a gsl_matrix pointer for efficiency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The first input matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>The second input matrix. </td></tr>
    <tr><td class="paramname">tmp</td><td>The output matrix to store the resulting sum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All input matrices must have the same dimensions.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The output matrix 'tmp' contains the element-wise sum of 'm1' and 'm2'. </dd></dl>

</div>
</div>
<a id="ae19df5533c4af952dfe47bb010b66646" name="ae19df5533c4af952dfe47bb010b66646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19df5533c4af952dfe47bb010b66646">&#9670;&#160;</a></span>assign_rowVec_to_colVec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assign_rowVec_to_colVec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>srcRowVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>destColVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the values in a row vector to a column vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcRowVec</td><td>Row vector containing the values to be copied. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">destColVec</td><td>Column vector to receive the copied values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the input matrices have incompatible dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71cbe43985593c79552d1e40002e5bbb" name="a71cbe43985593c79552d1e40002e5bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cbe43985593c79552d1e40002e5bbb">&#9670;&#160;</a></span>colvec_matrix_multiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colvec_matrix_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a row vector by a matrix and store the result in a row vector. </p>
<p>This function multiplies a row vector with a matrix and stores the resulting product in another row vector. All input matrices are assumed to be of type <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a>, which internally contains a gsl_matrix pointer for efficiency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The input row vector to be multiplied. </td></tr>
    <tr><td class="paramname">m1</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">tmp</td><td>The output row vector to store the resulting product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The number of columns of 'v1' must match the number of rows of 'm1', and the dimensions of 'tmp' must match the number of columns of 'm1'.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The output row vector 'tmp' contains the product of the input row vector 'v1' and the input matrix 'm1'.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>benchmark - In this case, if my matrices are small (&lt; 12 * 3), but I need to repeat these matrices calculation for a large number of times, is gsl_blas_dgemm still more eifficent?</dd></dl>
<p>For small matrices like the ones you've described, it's possible that an element-wise implementation could be faster than using gsl_blas_dgemm() due to the overhead associated with setting up the function call and memory management. However, this depends on the context in which the function is being used and the specific hardware being used.</p>
<p>If the calculation of these small matrices is being repeated a large number of times, then the overhead of setting up the function call and memory management might be amortized over multiple calculations, making gsl_blas_dgemm() more efficient.</p>
<p>Ultimately, the best approach would be to benchmark both implementations (element-wise and using gsl_blas_dgemm() on your specific system and compare their performance for your use case. </p>

</div>
</div>
<a id="a91de41df159ee60f4eecc860c7089c9b" name="a91de41df159ee60f4eecc860c7089c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91de41df159ee60f4eecc860c7089c9b">&#9670;&#160;</a></span>const_division()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void const_division </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide a matrix by a constant and store the result in a second matrix. </p>
<p>This function divides the elements of an input matrix by a scalar constant and stores the result in a second output matrix. All input matrices are assumed to be of type <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The input matrix to be divided. </td></tr>
    <tr><td class="paramname">num</td><td>The scalar constant to divide by. </td></tr>
    <tr><td class="paramname">tmp</td><td>The output matrix to store the resulting quotient.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The dimensions of 'm1' and 'tmp' must match.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The output matrix 'tmp' contains the element-wise division of 'm1' and 'num'. </dd></dl>

</div>
</div>
<a id="ae8380f2d0eae7bf33cdb07560747ea72" name="ae8380f2d0eae7bf33cdb07560747ea72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8380f2d0eae7bf33cdb07560747ea72">&#9670;&#160;</a></span>const_multiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void const_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a matrix by a constant and store the result in a second matrix. </p>
<p>This function multiplies the elements of an input matrix with a scalar constant and stores the result in a second output matrix. All input matrices are assumed to be of type <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The input matrix to be multiplied. </td></tr>
    <tr><td class="paramname">num</td><td>The scalar constant to multiply with. </td></tr>
    <tr><td class="paramname">tmp</td><td>The output matrix to store the resulting product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The dimensions of 'm1' and 'tmp' must match.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The output matrix 'tmp' contains the element-wise multiplication of 'm1' and 'num'. </dd></dl>

</div>
</div>
<a id="aa61de292b027fd1d36cd57eb8a679c65" name="aa61de292b027fd1d36cd57eb8a679c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61de292b027fd1d36cd57eb8a679c65">&#9670;&#160;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cross product of two 3D vectors represented as 3x1 matrices. </p>
<p>This function computes the cross product of two input vectors, which are assumed to be 3x1 matrices. The result is stored in another 3x1 matrix passed in as an argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The first input vector as a 3x1 matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>The second input vector as a 3x1 matrix. </td></tr>
    <tr><td class="paramname">temp</td><td>The output matrix to store the resulting cross product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All input matrices must have 3 rows and 1 column.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The output matrix 'temp' contains the cross product of 'm1' and 'm2'. </dd></dl>

</div>
</div>
<a id="a74ef398ea342aaaa6bef5128e9bf15a8" name="a74ef398ea342aaaa6bef5128e9bf15a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ef398ea342aaaa6bef5128e9bf15a8">&#9670;&#160;</a></span>cross_col()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> cross_col </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implementation takes two column vectors as arguments and returns their cross product as a new column vector. </p>
<dl class="section note"><dt>Note</dt><dd>Note that this implementation assumes that the input matrices are already column vectors, so no additional transposition is necessary. </dd></dl>

</div>
</div>
<a id="a8c3bf9ef46fde8b009e48d735c668d93" name="a8c3bf9ef46fde8b009e48d735c668d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3bf9ef46fde8b009e48d735c668d93">&#9670;&#160;</a></span>cross_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> cross_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implementation takes two row vectors as arguments and returns their cross product as a new row vector. </p>
<dl class="section note"><dt>Note</dt><dd>Note that this implementation assumes that the input matrices are already row vectors, so no additional transposition is necessary. </dd></dl>

</div>
</div>
<a id="aed5a7001ababed63208a5f37d4da8a6e" name="aed5a7001ababed63208a5f37d4da8a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5a7001ababed63208a5f37d4da8a6e">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16f2d841a7bbc07c6ed264848e532536" name="a16f2d841a7bbc07c6ed264848e532536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f2d841a7bbc07c6ed264848e532536">&#9670;&#160;</a></span>dot_col()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dot_col </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implementation takes two column vectors as arguments and returns their dot product as double. </p>
<dl class="section note"><dt>Note</dt><dd>Note that this implementation assumes that the input matrices are already column vectors, so no additional transposition is necessary. </dd></dl>

</div>
</div>
<a id="a1321d248693d484c54370beae277e19d" name="a1321d248693d484c54370beae277e19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1321d248693d484c54370beae277e19d">&#9670;&#160;</a></span>dot_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dot_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implementation takes two row vectors as arguments and returns their dot product as double. </p>
<dl class="section note"><dt>Note</dt><dd>Note that this implementation converts the row vectors into column vectors before computing the dot product. </dd></dl>

</div>
</div>
<a id="a4baa40e609ed63be814718a4b8dd2f56" name="a4baa40e609ed63be814718a4b8dd2f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4baa40e609ed63be814718a4b8dd2f56">&#9670;&#160;</a></span>get_unit_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_unit_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m_unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unit vector in the direction of m1 which is a (3, 1) <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a>. </p>
<p>This function computes the unit vector in the direction of a given input vector, which is assumed to be a 3x1 matrix. The result is stored in another 3x1 matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The input vector to compute the unit vector of. </td></tr>
    <tr><td class="paramname">m_unit</td><td>The output matrix to store the resulting unit vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input matrix 'm1' must be a 3x1 matrix.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The output matrix 'm_unit' contains the unit vector in the direction of 'm1'. </dd></dl>

</div>
</div>
<a id="a476d951514d654f916418cee7d5b189f" name="a476d951514d654f916418cee7d5b189f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476d951514d654f916418cee7d5b189f">&#9670;&#160;</a></span>kron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> kron </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the Kronecker product between two column matrices and returns the result in an output matrix. The Kronecker product is defined as follows: </p>
<pre class="fragment">kron(v1, v2) = [v1(1)*v2(1)  v1(1)*v2(2)  ...  v1(1)*v2(n2)
                v1(2)*v2(1)  v1(2)*v2(2)  ...  v1(2)*v2(n2)
                ...          ...          ...  ...
                v1(n1)*v2(1)  v1(n1)*v2(2)  ...  v1(n1)*v2(n2)]
</pre><p> where v1 and v2 are column matrices of size n1 and n2 respectively, and the output matrix has size n1*n2 x n1*n2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>First input column matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Second input column matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Might cause memory leak! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Output matrix to store the result.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the output matrix has incompatible dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0131af41656cb51262343c655b461a4" name="ae0131af41656cb51262343c655b461a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0131af41656cb51262343c655b461a4">&#9670;&#160;</a></span>kron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> kron </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the Kronecker product between two column matrices and returns the result in an output matrix. The Kronecker product is defined as follows: </p>
<pre class="fragment">kron(v1, v2) = [v1(1)*v2(1)  v1(1)*v2(2)  ...  v1(1)*v2(n2)
                v1(2)*v2(1)  v1(2)*v2(2)  ...  v1(2)*v2(n2)
                ...          ...          ...  ...
                v1(n1)*v2(1)  v1(n1)*v2(2)  ...  v1(n1)*v2(n2)]
</pre><p> where v1 and v2 are column matrices of size n1 and n2 respectively, and the output matrix has size n1*n2 x n1*n2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>First input column matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Second input column matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m_result</td><td>Output matrix to store the result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af45abfc5a0e5e23d8aabcea64c339312" name="af45abfc5a0e5e23d8aabcea64c339312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45abfc5a0e5e23d8aabcea64c339312">&#9670;&#160;</a></span>mat_calloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> mat_calloc </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ncol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allocates a new <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> object with the specified number of rows and columns, and initializes all elements to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nrow</td><td></td></tr>
    <tr><td class="paramname">ncol</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> </dd></dl>

</div>
</div>
<a id="a7babd9d5d81db0f04b3e8fccc0ca0e76" name="a7babd9d5d81db0f04b3e8fccc0ca0e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7babd9d5d81db0f04b3e8fccc0ca0e76">&#9670;&#160;</a></span>multiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a matrix by a constant and store the result in a second matrix. </p>
<p>This function multiplies the elements of an input matrix with a scalar constant and stores the result in a second output matrix. All input matrices are assumed to be of type <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The input matrix to be multiplied. </td></tr>
    <tr><td class="paramname">num</td><td>The scalar constant to multiply with. </td></tr>
    <tr><td class="paramname">tmp</td><td>The output matrix to store the resulting product.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The dimensions of 'm1' and 'tmp' must match.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The output matrix 'tmp' contains the element-wise multiplication of 'm1' and 'num'. </dd></dl>

</div>
</div>
<a id="ae5fa66935b125fb2613ffe2ce57e935f" name="ae5fa66935b125fb2613ffe2ce57e935f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fa66935b125fb2613ffe2ce57e935f">&#9670;&#160;</a></span>negative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void negative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m_neg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the negative of a given matrix. </p>
<p>This function computes the element-wise negative of a given matrix and stores the result in another matrix. Element-wise negative is defined as multiplying each element of the matrix with -1. The input matrix 'm1' is not modified by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The matrix to compute the negative of. </td></tr>
    <tr><td class="paramname">m_neg</td><td>The matrix to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Both matrices 'm1' and 'm_neg' must have been allocated memory and initialized properly. </dd>
<dd>
Both matrices 'm1' and 'm_neg' must have the same dimensions.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The matrix 'm_neg' contains the element-wise negative of 'm1'. </dd></dl>

</div>
</div>
<a id="a64c608ba3c31fd9088fd759188ae2c1a" name="a64c608ba3c31fd9088fd759188ae2c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c608ba3c31fd9088fd759188ae2c1a">&#9670;&#160;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24da5fd1a21f5010ee32de71af9be3b9" name="a24da5fd1a21f5010ee32de71af9be3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24da5fd1a21f5010ee32de71af9be3b9">&#9670;&#160;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implementation checks that the matrices have compatible dimensions for multiplication and uses the BLAS library to perform the matrix multiplication. The result is stored in a newly allocated matrix result, which is then returned. The temporary memory is not freed here, and it is the responsibility of the caller to free the memory once the result is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td></td></tr>
    <tr><td class="paramname">m2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> </dd></dl>

</div>
</div>
<a id="ac1628fdfaebf401b1cbc5116540ba779" name="ac1628fdfaebf401b1cbc5116540ba779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1628fdfaebf401b1cbc5116540ba779">&#9670;&#160;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operator takes a double scalar and a matrix as its operands. It returns a new gsl_matrix* that is the result of scaling the input matrix by the scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td></td></tr>
    <tr><td class="paramname">matrix</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> </dd></dl>

</div>
</div>
<a id="a3fdf5f190807099ee79e068f83eb517e" name="a3fdf5f190807099ee79e068f83eb517e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdf5f190807099ee79e068f83eb517e">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implementation uses the gsl_matrix_scale function to scale each element in the matrix by the scalar value. The function returns the modified matrix, which allows for method chaining when using the *= operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td></td></tr>
    <tr><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> </dd></dl>

</div>
</div>
<a id="a4a0a835103a72d65a8d4038c34d4a773" name="a4a0a835103a72d65a8d4038c34d4a773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0a835103a72d65a8d4038c34d4a773">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implementation checks that the matrices have compatible dimensions for multiplication and uses the BLAS library to perform the matrix multiplication. The result is stored in a temporary matrix, which is then copied back into m1. Finally, the temporary memory is freed before returning m1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td></td></tr>
    <tr><td class="paramname">m2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> </dd></dl>

</div>
</div>
<a id="aa5a9f2db2b3c1862c9c0d19241239ce7" name="aa5a9f2db2b3c1862c9c0d19241239ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a9f2db2b3c1862c9c0d19241239ce7">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implementation checks that the matrices have the same dimensions and allocates memory for the result of the addition. It then adds the matrices element-wise and stores the result in a newly allocated matrix result, which is then returned. </p>

</div>
</div>
<a id="a2d1976903224767c788b0f3e5846bd6c" name="a2d1976903224767c788b0f3e5846bd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1976903224767c788b0f3e5846bd6c">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implementation takes two gsl_matrix pointers as arguments and adds the elements of the second matrix to the first matrix. It first checks that the matrices have the same dimensions, and throws an exception if they do not. Then it iterates over the elements of the matrices and adds the corresponding elements. Finally, it returns a pointer to the modified first matrix. Note that this implementation modifies the first matrix in place, rather than creating a new matrix. If you want to create a new matrix instead, you could modify the implementation accordingly. </p>

</div>
</div>
<a id="a52ad5ef4b9998529c85e8523c20d6b86" name="a52ad5ef4b9998529c85e8523c20d6b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ad5ef4b9998529c85e8523c20d6b86">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implementation checks that the matrices have the same dimensions and allocates memory for the result of the subtraction. It then adds the matrices element-wise and stores the result in a newly allocated matrix result, which is then returned. </p>

</div>
</div>
<a id="a279fb974b0ba51b716f08f8f74417acc" name="a279fb974b0ba51b716f08f8f74417acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279fb974b0ba51b716f08f8f74417acc">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implementation takes two gsl_matrix pointers as arguments and subtract the elements of the second matrix from the first matrix. It first checks that the matrices have the same dimensions, and throws an exception if they do not. Then it iterates over the elements of the matrices and adds the corresponding elements. Finally, it returns a pointer to the modified first matrix. Note that this implementation modifies the first matrix in place, rather than creating a new matrix. If you want to create a new matrix instead, you could modify the implementation accordingly. </p>

</div>
</div>
<a id="a287766f48ce1537b4789b890515572cb" name="a287766f48ce1537b4789b890515572cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287766f48ce1537b4789b890515572cb">&#9670;&#160;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operator takes a double scalar and a matrix as its operands. It returns a new gsl_matrix* that is the result of scaling the input matrix by 1/scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td></td></tr>
    <tr><td class="paramname">matrix</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> </dd></dl>

</div>
</div>
<a id="a4982f65adbc5a3f46660ba7eb704b3c4" name="a4982f65adbc5a3f46660ba7eb704b3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4982f65adbc5a3f46660ba7eb704b3c4">&#9670;&#160;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implementation uses the gsl_matrix_scale function to scale each element in the matrix by 1/the scalar value. The function returns the modified matrix, which allows for method chaining when using the *= operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td></td></tr>
    <tr><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> </dd></dl>

</div>
</div>
<a id="a391be9262318fa95cf1c7c21d0afa0f9" name="a391be9262318fa95cf1c7c21d0afa0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391be9262318fa95cf1c7c21d0afa0f9">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit push all element of a matrix in the format of: </p>
<p>a11, a12, a13, ..., a21, a22, a23, ..., ...,</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>ostream </td></tr>
    <tr><td class="paramname">matrix</td><td>matrix to be output as string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp; </dd></dl>

</div>
</div>
<a id="a16c686d2f9ed45866109caffe69b246b" name="a16c686d2f9ed45866109caffe69b246b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c686d2f9ed45866109caffe69b246b">&#9670;&#160;</a></span>subtraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void subtraction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the element-wise subtraction of two matrices and store the result in a third matrix. </p>
<p>This function computes the element-wise subtraction of two input matrices of equal dimensions and stores the result in a third matrix. All input matrices are assumed to be of type <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a>, which internally contains a gsl_matrix pointer for efficiency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The first input matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>The second input matrix. </td></tr>
    <tr><td class="paramname">tmp</td><td>The output matrix to store the resulting difference.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All input matrices must have the same dimensions.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The output matrix 'tmp' contains the element-wise difference of 'm1' and 'm2'. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
