<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Continuum Membrane: DynamicMesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Continuum Membrane
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classDynamicMesh-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DynamicMesh Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class representing a dynamic mesh.  
 <a href="classDynamicMesh.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Dynamics_8hpp_source.html">Dynamics.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DynamicMesh:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classDynamicMesh.png" usemap="#DynamicMesh_map" alt=""/>
  <map id="DynamicMesh_map" name="DynamicMesh_map">
<area href="classMesh.html" title="A class representing a triangular mesh that defines a limit surface." alt="Mesh" shape="rect" coords="0,0,92,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2645f64e9f57420cdb7d4371229ead73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicMesh.html#a2645f64e9f57420cdb7d4371229ead73">DynamicMesh</a> (<a class="el" href="structParam.html">Param</a> &amp;srcParam)</td></tr>
<tr class="memdesc:a2645f64e9f57420cdb7d4371229ead73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Dynamic <a class="el" href="classMesh.html" title="A class representing a triangular mesh that defines a limit surface.">Mesh</a> object. Calls the parent constructor Mesh::Mesh(srcParam).  <br /></td></tr>
<tr class="separator:a2645f64e9f57420cdb7d4371229ead73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab771f9438974285e84848183c2a995f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicMesh.html#aab771f9438974285e84848183c2a995f">setup_flat</a> ()</td></tr>
<tr class="memdesc:aab771f9438974285e84848183c2a995f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the setup_flat in superclass <a class="el" href="classMesh.html" title="A class representing a triangular mesh that defines a limit surface.">Mesh</a>. Add functionality to assign mesh2surface and surface2mesh.  <br /></td></tr>
<tr class="separator:aab771f9438974285e84848183c2a995f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aafcb958f1025e72ccd54645ca2cd84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicMesh.html#a6aafcb958f1025e72ccd54645ca2cd84">assign_mesh2surface</a> ()</td></tr>
<tr class="memdesc:a6aafcb958f1025e72ccd54645ca2cd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the mesh2surface member.  <br /></td></tr>
<tr class="separator:a6aafcb958f1025e72ccd54645ca2cd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013dfec614038a1f8fb698d513e30749"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicMesh.html#a013dfec614038a1f8fb698d513e30749">update_vertices_mat_with_vector</a> ()</td></tr>
<tr class="memdesc:a013dfec614038a1f8fb698d513e30749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the vertices matrix using the values from the vertices vector.  <br /></td></tr>
<tr class="separator:a013dfec614038a1f8fb698d513e30749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7211c963b65e06b235b3e4dd1c5fd7ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicMesh.html#a7211c963b65e06b235b3e4dd1c5fd7ef">update_vertices_vector_with_mat</a> ()</td></tr>
<tr class="memdesc:a7211c963b65e06b235b3e4dd1c5fd7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the vertices vector using the values from the vertices matrix.  <br /></td></tr>
<tr class="separator:a7211c963b65e06b235b3e4dd1c5fd7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d18117779c2f559cc914a3b613317e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicMesh.html#a7d18117779c2f559cc914a3b613317e3">postprocess_ghost_periodic</a> ()</td></tr>
<tr class="memdesc:a7d18117779c2f559cc914a3b613317e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post process ghost vertices in case of periodic boundary condition.  <br /></td></tr>
<tr class="separator:a7d18117779c2f559cc914a3b613317e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classMesh"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classMesh')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classMesh.html">Mesh</a></td></tr>
<tr class="memitem:a0685f9dfb74d633c092886d56afffb6e inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a0685f9dfb74d633c092886d56afffb6e">Mesh</a> (<a class="el" href="structParam.html">Param</a> &amp;srcParam)</td></tr>
<tr class="memdesc:a0685f9dfb74d633c092886d56afffb6e inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classMesh.html" title="A class representing a triangular mesh that defines a limit surface.">Mesh</a> object with parameters. Initialize vertices and faces with other functions like setVerticesFlat.  <br /></td></tr>
<tr class="separator:a0685f9dfb74d633c092886d56afffb6e inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab78f3a30742a937d9a387287ce323c inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#aaab78f3a30742a937d9a387287ce323c">Mesh</a> (const std::vector&lt; <a class="el" href="classVertex.html">Vertex</a> &gt; &amp;srcVertices, const std::vector&lt; <a class="el" href="classFace.html">Face</a> &gt; &amp;srcFaces, <a class="el" href="structParam.html">Param</a> &amp;srcParam) __attribute__((deprecated(&quot;Initialize with <a class="el" href="classMesh.html">Mesh</a>(<a class="el" href="structParam.html">Param</a> &amp;srcParam) and setup with <a class="el" href="classMesh.html#a9573e3cbf642233168d9a6e70d5a1a57">setup_from_vertices_faces</a> instead.&quot;)))</td></tr>
<tr class="memdesc:aaab78f3a30742a937d9a387287ce323c inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new mesh object with given vertices, faces, and parameters.  <br /></td></tr>
<tr class="separator:aaab78f3a30742a937d9a387287ce323c inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdc2aaee5e4762f56c6637b16506f2d inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#affdc2aaee5e4762f56c6637b16506f2d">setup_flat</a> ()</td></tr>
<tr class="memdesc:affdc2aaee5e4762f56c6637b16506f2d inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize halfedges based on the mesh's vertices and faces.  <br /></td></tr>
<tr class="separator:affdc2aaee5e4762f56c6637b16506f2d inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9573e3cbf642233168d9a6e70d5a1a57 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a9573e3cbf642233168d9a6e70d5a1a57">setup_from_vertices_faces</a> (const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;verticesData, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;facesData)</td></tr>
<tr class="memdesc:a9573e3cbf642233168d9a6e70d5a1a57 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize membrane with arbitrary vertices and faces imported from files. Sets up the membrane from data and then call: (1) this-&gt;set_adjacent_faces_of_vertices_sorted (2) this-&gt;determine_ghost_vertices_faces.  <br /></td></tr>
<tr class="separator:a9573e3cbf642233168d9a6e70d5a1a57 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b21ba1a874da6dc75cfa473d02a747 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a99b21ba1a874da6dc75cfa473d02a747">set_axes_division_flat</a> ()</td></tr>
<tr class="memdesc:a99b21ba1a874da6dc75cfa473d02a747 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide x,y axis to nx*dx (number of faces times length of each face) and ny*dy based on X, Y side length of the mesh and side length of faces in parameter. Note:  <br /></td></tr>
<tr class="separator:a99b21ba1a874da6dc75cfa473d02a747 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac531dabf200ff831464999c03f345707 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ac531dabf200ff831464999c03f345707">set_vertices_faces_flat</a> ()</td></tr>
<tr class="memdesc:ac531dabf200ff831464999c03f345707 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set vertices and faces according to mesh and face side lengths in param for flat mesh. This also sets adjacent vertices of faces.  <br /></td></tr>
<tr class="separator:ac531dabf200ff831464999c03f345707 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed33be097663033bc75853c33c3333ed inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#aed33be097663033bc75853c33c3333ed">set_adjacent_faces_of_vertices_sorted</a> ()</td></tr>
<tr class="memdesc:aed33be097663033bc75853c33c3333ed inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set adjacentFaces properties based on the current vertices and mesh. Sort the adjacent vertices so that the adjacent vertices property of vertices follow the counterclockwise order and therefore the the adjacent faces with index number difference of one are adjacent to each other. This sorting streamlines the shapefunction calculation.  <br /></td></tr>
<tr class="separator:aed33be097663033bc75853c33c3333ed inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3701b70db1a2940cbda09d8d8ae36dc0 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a3701b70db1a2940cbda09d8d8ae36dc0">set_adjacent_vertices_of_vertices_sorted</a> ()</td></tr>
<tr class="memdesc:a3701b70db1a2940cbda09d8d8ae36dc0 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set adjacentVertices of vertices based on current mesh.  <br /></td></tr>
<tr class="separator:a3701b70db1a2940cbda09d8d8ae36dc0 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93250c015872ef461069e436ec0d7be inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ae93250c015872ef461069e436ec0d7be">find_opposite_node_index</a> (const int &amp;node1, const int &amp;node2, const int &amp;node3)</td></tr>
<tr class="memdesc:ae93250c015872ef461069e436ec0d7be inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the vertex that is adjacent to node1 and node2 but not node3. Particularly, when the three nodes are vertices of a triangle, then the function returns the the index of node4 that forms a parallegram with 1-&gt;3-&gt;2-&gt;4.  <br /></td></tr>
<tr class="separator:ae93250c015872ef461069e436ec0d7be inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c95e1c6ae386b81d44558273b10a1e inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a83c95e1c6ae386b81d44558273b10a1e">set_one_ring_vertices_sorted</a> ()</td></tr>
<tr class="memdesc:a83c95e1c6ae386b81d44558273b10a1e inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">find out the one-ring vertices aound face_i. It should be 12 for the flat surface because we set it up only with regular patch. The boundary faces do not have complete one-ring, neither it will be called in the code, so no need to store their one-ring-vertex  <br /></td></tr>
<tr class="separator:a83c95e1c6ae386b81d44558273b10a1e inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5bfdb2d69c0d217dff5b1fd83ed0f5 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#aef5bfdb2d69c0d217dff5b1fd83ed0f5">determine_boundary_vertices_faces</a> ()</td></tr>
<tr class="memdesc:aef5bfdb2d69c0d217dff5b1fd83ed0f5 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through vertices and faces and set the isBoundary} property of boundary vertices and faces to true}.  <br /></td></tr>
<tr class="separator:aef5bfdb2d69c0d217dff5b1fd83ed0f5 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744de61088daa25cc58ae32c07020e5d inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a744de61088daa25cc58ae32c07020e5d">determine_ghost_vertices_faces</a> ()</td></tr>
<tr class="memdesc:a744de61088daa25cc58ae32c07020e5d inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through vertices and faces and set the isGhost property of ghost vertices and face to true. The number of layers of ghost vertices in a flat membrane is dependent upon the boundary conditions: free boundary condition has 1 layer of ghost vertices and faces while periodic bounary condition has 3 layers of ghost vertices.  <br /></td></tr>
<tr class="separator:a744de61088daa25cc58ae32c07020e5d inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03d9aefdf5b321200fc4f1a6354c1c8 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ae03d9aefdf5b321200fc4f1a6354c1c8">set_insertion_patch</a> (const vector&lt; vector&lt; int &gt; &gt; &amp;insertionPatch)</td></tr>
<tr class="memdesc:ae03d9aefdf5b321200fc4f1a6354c1c8 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the isInsertionPatch flag for each face in the insertion patch. This also sets with spontaneous curvature after setting the flag with set_spontaneous_curvature_for_face function.  <br /></td></tr>
<tr class="separator:ae03d9aefdf5b321200fc4f1a6354c1c8 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c686d28a291b262ca1c026dba2e817 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ae3c686d28a291b262ca1c026dba2e817">set_spontaneous_curvature_for_face</a> (const double &amp;insertCurv, const double &amp;spontCurv)</td></tr>
<tr class="memdesc:ae3c686d28a291b262ca1c026dba2e817 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the spontaneous curvature for each face in the mesh.  <br /></td></tr>
<tr class="separator:ae3c686d28a291b262ca1c026dba2e817 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acaf454a27868a6ed2ff0ddf4aff64e inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a0acaf454a27868a6ed2ff0ddf4aff64e">calculate_element_area_volume</a> ()</td></tr>
<tr class="memdesc:a0acaf454a27868a6ed2ff0ddf4aff64e inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area and volume of each element in the mesh.  <br /></td></tr>
<tr class="separator:a0acaf454a27868a6ed2ff0ddf4aff64e inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf7a146011c884429c5d5009850d834 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#acbf7a146011c884429c5d5009850d834">sum_membrane_area_and_volume</a> (double &amp;area, double &amp;volume)</td></tr>
<tr class="memdesc:acbf7a146011c884429c5d5009850d834 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the total membrane area and volume of non-ghost faces in a given set of faces.  <br /></td></tr>
<tr class="separator:acbf7a146011c884429c5d5009850d834 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3b6819bae35b86e80ba1c4104c8269 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#afe3b6819bae35b86e80ba1c4104c8269">Compute_Energy_And_Force</a> ()</td></tr>
<tr class="memdesc:afe3b6819bae35b86e80ba1c4104c8269 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the energy and force on each vertex and face of the mesh.  <br /></td></tr>
<tr class="separator:afe3b6819bae35b86e80ba1c4104c8269 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e3994d78b0224d9759fe4ed4b4c6d5 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ab3e3994d78b0224d9759fe4ed4b4c6d5">element_energy_force_regular</a> (const std::vector&lt; <a class="el" href="classMatrix.html">Matrix</a> &gt; &amp;coordOneRingVertices, <a class="el" href="classFace.html">Face</a> &amp;face, const double spontCurv, double &amp;meanCurv, <a class="el" href="classMatrix.html">Matrix</a> &amp;normVector, double &amp;eBend, <a class="el" href="classMatrix.html">Matrix</a> &amp;fBend, <a class="el" href="classMatrix.html">Matrix</a> &amp;fArea, <a class="el" href="classMatrix.html">Matrix</a> &amp;fVolume)</td></tr>
<tr class="memdesc:ab3e3994d78b0224d9759fe4ed4b4c6d5 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The purpose of this function is to calculate the energy and forces for a regular element of a given mesh using the provided information about the element and its one-ring neighborhood.  <br /></td></tr>
<tr class="separator:ab3e3994d78b0224d9759fe4ed4b4c6d5 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290b3c7dd1e39da6095b5d12da1b2c8c inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a290b3c7dd1e39da6095b5d12da1b2c8c">energy_force_regularization</a> ()</td></tr>
<tr class="memdesc:a290b3c7dd1e39da6095b5d12da1b2c8c inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the regularization energy and force for each face.  <br /></td></tr>
<tr class="separator:a290b3c7dd1e39da6095b5d12da1b2c8c inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5818bb84a71e7d6e4da2cd0a2da96cfb inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a5818bb84a71e7d6e4da2cd0a2da96cfb">manage_force_for_boundary_ghost_vertex</a> ()</td></tr>
<tr class="memdesc:a5818bb84a71e7d6e4da2cd0a2da96cfb inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages forces depending on different boundary conditions.  <br /></td></tr>
<tr class="separator:a5818bb84a71e7d6e4da2cd0a2da96cfb inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9a489b9658c52c771d8aeb86761cff inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a0d9a489b9658c52c771d8aeb86761cff">get_max_force_magnitude</a> ()</td></tr>
<tr class="memdesc:a0d9a489b9658c52c771d8aeb86761cff inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the max force scale of vertices.force.get_total_force_magnitude()  <br /></td></tr>
<tr class="separator:a0d9a489b9658c52c771d8aeb86761cff inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae709a12efd5127a80c9e53298d175b8b inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ae709a12efd5127a80c9e53298d175b8b">calculate_mean_force</a> ()</td></tr>
<tr class="memdesc:ae709a12efd5127a80c9e53298d175b8b inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mean force magnitude on all vertices.  <br /></td></tr>
<tr class="separator:ae709a12efd5127a80c9e53298d175b8b inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8f4f14e01b2dc240eedb9ea4d71ff8 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ace8f4f14e01b2dc240eedb9ea4d71ff8">update_previous_coord_for_vertex</a> ()</td></tr>
<tr class="memdesc:ace8f4f14e01b2dc240eedb9ea4d71ff8 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the coordPrev member variable for each vertex in the mesh. It does this by copying the current value of coord to coordPrev.  <br /></td></tr>
<tr class="separator:ace8f4f14e01b2dc240eedb9ea4d71ff8 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3789d9eb9e117406a17167c3b9cee1e4 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a3789d9eb9e117406a17167c3b9cee1e4">update_reference_coord_from_previous_coord</a> ()</td></tr>
<tr class="memdesc:a3789d9eb9e117406a17167c3b9cee1e4 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the reference coordinates for each vertex in the mesh.  <br /></td></tr>
<tr class="separator:a3789d9eb9e117406a17167c3b9cee1e4 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195aba6e11cd1d7a55604c2c337d65c4 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a195aba6e11cd1d7a55604c2c337d65c4">update_previous_force_for_vertex</a> ()</td></tr>
<tr class="memdesc:a195aba6e11cd1d7a55604c2c337d65c4 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the previous force vectors for each vertex in the mesh.  <br /></td></tr>
<tr class="separator:a195aba6e11cd1d7a55604c2c337d65c4 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e83327f9919ee1de80e19f0f3e38a6 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a79e83327f9919ee1de80e19f0f3e38a6">update_previous_energy_for_face</a> ()</td></tr>
<tr class="memdesc:a79e83327f9919ee1de80e19f0f3e38a6 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the previous energy values for each face in the mesh.  <br /></td></tr>
<tr class="separator:a79e83327f9919ee1de80e19f0f3e38a6 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742357b9318965689249acd31601642e inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a742357b9318965689249acd31601642e">clear_force_on_vertices_and_energy_on_faces</a> ()</td></tr>
<tr class="memdesc:a742357b9318965689249acd31601642e inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function sets the force member variable of each vertex, and the energy member variable of each face to their default values. This is useful to clear out any residual forces or energies before computing new ones.  <br /></td></tr>
<tr class="separator:a742357b9318965689249acd31601642e inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbefd57ee3d41858d212263d1dc8024 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a0dbefd57ee3d41858d212263d1dc8024">move_vertices_based_on_scaffolding</a> (bool fixDir=true)</td></tr>
<tr class="memdesc:a0dbefd57ee3d41858d212263d1dc8024 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes in the vector of spline point and calculate the average coordinates. Based on the difference between spline points and mesh vertices, a difference vector is calculated and compared to the target bond length. (Supposed only in Z direction). Afterwards, all the mesh points are moved in the direction of the target difference vector.  <br /></td></tr>
<tr class="separator:a0dbefd57ee3d41858d212263d1dc8024 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e11a64d5b45a2ce39b70325f7ff9a4e inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a6e11a64d5b45a2ce39b70325f7ff9a4e">set_scaffolding_vertices_correspondence</a> ()</td></tr>
<tr class="memdesc:a6e11a64d5b45a2ce39b70325f7ff9a4e inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of indexes of vertices that are closest to the scaffoldingPoints vector provided. Then set the param.scaffoldingPoints_correspondingVertexIndex} to represent the vertices bonded with each scaffolding point.  <br /></td></tr>
<tr class="separator:a6e11a64d5b45a2ce39b70325f7ff9a4e inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4290cf23bd9694e577e9ba73990df3 inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a9d4290cf23bd9694e577e9ba73990df3">calculate_scaffolding_energy_force</a> (bool doLocalSearch)</td></tr>
<tr class="memdesc:a9d4290cf23bd9694e577e9ba73990df3 inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the energy and force due to the harmonic bond between scaffold points and membrane vertices.  <br /></td></tr>
<tr class="separator:a9d4290cf23bd9694e577e9ba73990df3 inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb6aca91c6fbd690653536eced038bf inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a5bb6aca91c6fbd690653536eced038bf">write_faces_csv</a> (const std::string &amp;outfile_name)</td></tr>
<tr class="memdesc:a5bb6aca91c6fbd690653536eced038bf inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a csv file containing the adjacent vertices for each face in the mesh.  <br /></td></tr>
<tr class="separator:a5bb6aca91c6fbd690653536eced038bf inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24565ddc787b2fd6c78fc8715c5bbd0a inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a24565ddc787b2fd6c78fc8715c5bbd0a">write_vertices_csv</a> (const std::string &amp;outfile_name)</td></tr>
<tr class="memdesc:a24565ddc787b2fd6c78fc8715c5bbd0a inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a csv file containing the coordinates of each vertex in the mesh.  <br /></td></tr>
<tr class="separator:a24565ddc787b2fd6c78fc8715c5bbd0a inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac641af43730870056e0ba395856a771a inherit pub_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ac641af43730870056e0ba395856a771a">write_vertices_csv_with_type</a> (const std::string &amp;outfile_name)</td></tr>
<tr class="memdesc:ac641af43730870056e0ba395856a771a inherit pub_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a csv file containing the coordinates and types of each vertex in the mesh.  <br /></td></tr>
<tr class="separator:ac641af43730870056e0ba395856a771a inherit pub_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a0da7485c97570d1945da13f50cf89570"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicMesh.html#a0da7485c97570d1945da13f50cf89570">mesh2surface</a></td></tr>
<tr class="separator:a0da7485c97570d1945da13f50cf89570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27e9f6f3b04928e6c8a7a6d3c43e4ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicMesh.html#aa27e9f6f3b04928e6c8a7a6d3c43e4ad">surface2mesh</a></td></tr>
<tr class="separator:aa27e9f6f3b04928e6c8a7a6d3c43e4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cd83fbd8c6cdcffb59ea24c28f3537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicMesh.html#a55cd83fbd8c6cdcffb59ea24c28f3537">matMesh</a></td></tr>
<tr class="separator:a55cd83fbd8c6cdcffb59ea24c28f3537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54946d4b69db8a53ff82550ef5a8263c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicMesh.html#a54946d4b69db8a53ff82550ef5a8263c">matSurface</a></td></tr>
<tr class="separator:a54946d4b69db8a53ff82550ef5a8263c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classMesh"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classMesh')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classMesh.html">Mesh</a></td></tr>
<tr class="memitem:a6465a888c97232a39e12aad008c969c3 inherit pub_attribs_classMesh"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classVertex.html">Vertex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a6465a888c97232a39e12aad008c969c3">vertices</a></td></tr>
<tr class="memdesc:a6465a888c97232a39e12aad008c969c3 inherit pub_attribs_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector to store all vertices in the mesh.  <br /></td></tr>
<tr class="separator:a6465a888c97232a39e12aad008c969c3 inherit pub_attribs_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da199719905f2b213f8c0c8feba2d1f inherit pub_attribs_classMesh"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classFace.html">Face</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a9da199719905f2b213f8c0c8feba2d1f">faces</a></td></tr>
<tr class="memdesc:a9da199719905f2b213f8c0c8feba2d1f inherit pub_attribs_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector to store all faces in the mesh.  <br /></td></tr>
<tr class="separator:a9da199719905f2b213f8c0c8feba2d1f inherit pub_attribs_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ce6a4fa3c43202516e8de3504478bc inherit pub_attribs_classMesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structParam.html">Param</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ae2ce6a4fa3c43202516e8de3504478bc">param</a></td></tr>
<tr class="memdesc:ae2ce6a4fa3c43202516e8de3504478bc inherit pub_attribs_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object of the <a class="el" href="structParam.html" title="Contains simulation parameters and physical constants.">Param</a> class containing all necessary parameters for building the <a class="el" href="classMesh.html" title="A class representing a triangular mesh that defines a limit surface.">Mesh</a> object.  <br /></td></tr>
<tr class="separator:ae2ce6a4fa3c43202516e8de3504478bc inherit pub_attribs_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af004fdce97e6ac0117071bdc473d430c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicMesh.html#af004fdce97e6ac0117071bdc473d430c">get_relative_pt_periodic</a> (int i, int n, int m)</td></tr>
<tr class="memdesc:af004fdce97e6ac0117071bdc473d430c"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate real point relative to the given ghost point (index(real) - index(given)) in periodic boundary condition returns 0 if real point (not on 4th ring) given an arbitrary real point is chosen if given 4th  <br /></td></tr>
<tr class="separator:af004fdce97e6ac0117071bdc473d430c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classMesh"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classMesh')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classMesh.html">Mesh</a></td></tr>
<tr class="memitem:a1820a26272a1ce4209a30032908c92d4 inherit pro_methods_classMesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a1820a26272a1ce4209a30032908c92d4">enumerate_gauss_quadrature_point_area_volume</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;dots, double &amp;area, double &amp;volume)</td></tr>
<tr class="memdesc:a1820a26272a1ce4209a30032908c92d4 inherit pro_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private member used in calculating element area volume: Calculates the area and volume at a Gauss quadrature point for a given set of shape functions and dots.  <br /></td></tr>
<tr class="separator:a1820a26272a1ce4209a30032908c92d4 inherit pro_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e1893669c41ee154462ceb0518a6b0 inherit pro_methods_classMesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a43e1893669c41ee154462ceb0518a6b0">get_one_ring_vertex_matrix</a> (const <a class="el" href="classFace.html">Face</a> &amp;face)</td></tr>
<tr class="memdesc:a43e1893669c41ee154462ceb0518a6b0 inherit pro_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private member used in calculating element area volume: Computes a matrix containing the coordinates of the one-ring vertices for the input face.  <br /></td></tr>
<tr class="separator:a43e1893669c41ee154462ceb0518a6b0 inherit pro_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a166003a4f1e86bbedfa5ee6867ff0d inherit pro_methods_classMesh"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a3a166003a4f1e86bbedfa5ee6867ff0d">get_squared_distance_sp_and_v</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;scaffoldingPoint, const <a class="el" href="classVertex.html">Vertex</a> &amp;vertex)</td></tr>
<tr class="memdesc:a3a166003a4f1e86bbedfa5ee6867ff0d inherit pro_methods_classMesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private member used in calculating correspondence between scaffolding points and vertices Calculate the squared distance between two points denoted by (3,1) <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> and <a class="el" href="classVertex.html" title="Defines a vertex in Mesh.">Vertex</a> respectively.  <br /></td></tr>
<tr class="separator:a3a166003a4f1e86bbedfa5ee6867ff0d inherit pro_methods_classMesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class representing a dynamic mesh. </p>
<p>This class inherits from the <a class="el" href="classMesh.html" title="A class representing a triangular mesh that defines a limit surface.">Mesh</a> class and adds functionality to simulate the mesh dynamically. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2645f64e9f57420cdb7d4371229ead73" name="a2645f64e9f57420cdb7d4371229ead73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2645f64e9f57420cdb7d4371229ead73">&#9670;&#160;</a></span>DynamicMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicMesh::DynamicMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParam.html">Param</a> &amp;&#160;</td>
          <td class="paramname"><em>srcParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new Dynamic <a class="el" href="classMesh.html" title="A class representing a triangular mesh that defines a limit surface.">Mesh</a> object. Calls the parent constructor Mesh::Mesh(srcParam). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcParam</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6aafcb958f1025e72ccd54645ca2cd84" name="a6aafcb958f1025e72ccd54645ca2cd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aafcb958f1025e72ccd54645ca2cd84">&#9670;&#160;</a></span>assign_mesh2surface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicMesh::assign_mesh2surface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the mesh2surface member. </p>
<p>Assign values to mesh2surface matrix that convertes mesh to surface point matrix. </p>

</div>
</div>
<a id="af004fdce97e6ac0117071bdc473d430c" name="af004fdce97e6ac0117071bdc473d430c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af004fdce97e6ac0117071bdc473d430c">&#9670;&#160;</a></span>get_relative_pt_periodic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DynamicMesh::get_relative_pt_periodic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculate real point relative to the given ghost point (index(real) - index(given)) in periodic boundary condition returns 0 if real point (not on 4th ring) given an arbitrary real point is chosen if given 4th </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td></td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a7d18117779c2f559cc914a3b613317e3" name="a7d18117779c2f559cc914a3b613317e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d18117779c2f559cc914a3b613317e3">&#9670;&#160;</a></span>postprocess_ghost_periodic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicMesh::postprocess_ghost_periodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post process ghost vertices in case of periodic boundary condition. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not have check for PBC - it assumes the model is in PBC! </dd></dl>

</div>
</div>
<a id="aab771f9438974285e84848183c2a995f" name="aab771f9438974285e84848183c2a995f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab771f9438974285e84848183c2a995f">&#9670;&#160;</a></span>setup_flat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicMesh::setup_flat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the setup_flat in superclass <a class="el" href="classMesh.html" title="A class representing a triangular mesh that defines a limit surface.">Mesh</a>. Add functionality to assign mesh2surface and surface2mesh. </p>

</div>
</div>
<a id="a013dfec614038a1f8fb698d513e30749" name="a013dfec614038a1f8fb698d513e30749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013dfec614038a1f8fb698d513e30749">&#9670;&#160;</a></span>update_vertices_mat_with_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicMesh::update_vertices_mat_with_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the vertices matrix using the values from the vertices vector. </p>

</div>
</div>
<a id="a7211c963b65e06b235b3e4dd1c5fd7ef" name="a7211c963b65e06b235b3e4dd1c5fd7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7211c963b65e06b235b3e4dd1c5fd7ef">&#9670;&#160;</a></span>update_vertices_vector_with_mat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicMesh::update_vertices_vector_with_mat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the vertices vector using the values from the vertices matrix. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a55cd83fbd8c6cdcffb59ea24c28f3537" name="a55cd83fbd8c6cdcffb59ea24c28f3537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cd83fbd8c6cdcffb59ea24c28f3537">&#9670;&#160;</a></span>matMesh</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> DynamicMesh::matMesh</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54946d4b69db8a53ff82550ef5a8263c" name="a54946d4b69db8a53ff82550ef5a8263c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54946d4b69db8a53ff82550ef5a8263c">&#9670;&#160;</a></span>matSurface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> DynamicMesh::matSurface</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0da7485c97570d1945da13f50cf89570" name="a0da7485c97570d1945da13f50cf89570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da7485c97570d1945da13f50cf89570">&#9670;&#160;</a></span>mesh2surface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> DynamicMesh::mesh2surface</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa27e9f6f3b04928e6c8a7a6d3c43e4ad" name="aa27e9f6f3b04928e6c8a7a6d3c43e4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27e9f6f3b04928e6c8a7a6d3c43e4ad">&#9670;&#160;</a></span>surface2mesh</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> DynamicMesh::surface2mesh</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="Dynamics_8hpp_source.html">Dynamics.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
