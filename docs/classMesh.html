<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Continuum Membrane: Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Continuum Membrane
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classMesh-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Mesh Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class representing a triangular mesh that defines a limit surface.  
 <a href="classMesh.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Mesh_8hpp_source.html">Mesh.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Mesh:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMesh.png" usemap="#Mesh_map" alt=""/>
  <map id="Mesh_map" name="Mesh_map">
<area href="classDynamicMesh.html" title="A class representing a dynamic mesh." alt="DynamicMesh" shape="rect" coords="0,56,92,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0685f9dfb74d633c092886d56afffb6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a0685f9dfb74d633c092886d56afffb6e">Mesh</a> (<a class="el" href="structParam.html">Param</a> &amp;srcParam)</td></tr>
<tr class="memdesc:a0685f9dfb74d633c092886d56afffb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classMesh.html" title="A class representing a triangular mesh that defines a limit surface.">Mesh</a> object with parameters. Initialize vertices and faces with other functions like setVerticesFlat.  <br /></td></tr>
<tr class="separator:a0685f9dfb74d633c092886d56afffb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab78f3a30742a937d9a387287ce323c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#aaab78f3a30742a937d9a387287ce323c">Mesh</a> (const std::vector&lt; <a class="el" href="classVertex.html">Vertex</a> &gt; &amp;srcVertices, const std::vector&lt; <a class="el" href="classFace.html">Face</a> &gt; &amp;srcFaces, <a class="el" href="structParam.html">Param</a> &amp;srcParam) __attribute__((deprecated(&quot;Initialize with <a class="el" href="classMesh.html">Mesh</a>(<a class="el" href="structParam.html">Param</a> &amp;srcParam) and setup with <a class="el" href="classMesh.html#a9573e3cbf642233168d9a6e70d5a1a57">setup_from_vertices_faces</a> instead.&quot;)))</td></tr>
<tr class="memdesc:aaab78f3a30742a937d9a387287ce323c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new mesh object with given vertices, faces, and parameters.  <br /></td></tr>
<tr class="separator:aaab78f3a30742a937d9a387287ce323c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdc2aaee5e4762f56c6637b16506f2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#affdc2aaee5e4762f56c6637b16506f2d">setup_flat</a> ()</td></tr>
<tr class="memdesc:affdc2aaee5e4762f56c6637b16506f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize halfedges based on the mesh's vertices and faces.  <br /></td></tr>
<tr class="separator:affdc2aaee5e4762f56c6637b16506f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9573e3cbf642233168d9a6e70d5a1a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a9573e3cbf642233168d9a6e70d5a1a57">setup_from_vertices_faces</a> (const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;verticesData, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;facesData)</td></tr>
<tr class="memdesc:a9573e3cbf642233168d9a6e70d5a1a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize membrane with arbitrary vertices and faces imported from files. Sets up the membrane from data and then call: (1) this-&gt;set_adjacent_faces_of_vertices_sorted (2) this-&gt;determine_ghost_vertices_faces.  <br /></td></tr>
<tr class="separator:a9573e3cbf642233168d9a6e70d5a1a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b21ba1a874da6dc75cfa473d02a747"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a99b21ba1a874da6dc75cfa473d02a747">set_axes_division_flat</a> ()</td></tr>
<tr class="memdesc:a99b21ba1a874da6dc75cfa473d02a747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide x,y axis to nx*dx (number of faces times length of each face) and ny*dy based on X, Y side length of the mesh and side length of faces in parameter. Note:  <br /></td></tr>
<tr class="separator:a99b21ba1a874da6dc75cfa473d02a747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac531dabf200ff831464999c03f345707"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ac531dabf200ff831464999c03f345707">set_vertices_faces_flat</a> ()</td></tr>
<tr class="memdesc:ac531dabf200ff831464999c03f345707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set vertices and faces according to mesh and face side lengths in param for flat mesh. This also sets adjacent vertices of faces.  <br /></td></tr>
<tr class="separator:ac531dabf200ff831464999c03f345707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed33be097663033bc75853c33c3333ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#aed33be097663033bc75853c33c3333ed">set_adjacent_faces_of_vertices_sorted</a> ()</td></tr>
<tr class="memdesc:aed33be097663033bc75853c33c3333ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set adjacentFaces properties based on the current vertices and mesh. Sort the adjacent vertices so that the adjacent vertices property of vertices follow the counterclockwise order and therefore the the adjacent faces with index number difference of one are adjacent to each other. This sorting streamlines the shapefunction calculation.  <br /></td></tr>
<tr class="separator:aed33be097663033bc75853c33c3333ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3701b70db1a2940cbda09d8d8ae36dc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a3701b70db1a2940cbda09d8d8ae36dc0">set_adjacent_vertices_of_vertices_sorted</a> ()</td></tr>
<tr class="memdesc:a3701b70db1a2940cbda09d8d8ae36dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set adjacentVertices of vertices based on current mesh.  <br /></td></tr>
<tr class="separator:a3701b70db1a2940cbda09d8d8ae36dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93250c015872ef461069e436ec0d7be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ae93250c015872ef461069e436ec0d7be">find_opposite_node_index</a> (const int &amp;node1, const int &amp;node2, const int &amp;node3)</td></tr>
<tr class="memdesc:ae93250c015872ef461069e436ec0d7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the vertex that is adjacent to node1 and node2 but not node3. Particularly, when the three nodes are vertices of a triangle, then the function returns the the index of node4 that forms a parallegram with 1-&gt;3-&gt;2-&gt;4.  <br /></td></tr>
<tr class="separator:ae93250c015872ef461069e436ec0d7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c95e1c6ae386b81d44558273b10a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a83c95e1c6ae386b81d44558273b10a1e">set_one_ring_vertices_sorted</a> ()</td></tr>
<tr class="memdesc:a83c95e1c6ae386b81d44558273b10a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find out the one-ring vertices aound face_i. It should be 12 for the flat surface because we set it up only with regular patch. The boundary faces do not have complete one-ring, neither it will be called in the code, so no need to store their one-ring-vertex  <br /></td></tr>
<tr class="separator:a83c95e1c6ae386b81d44558273b10a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5bfdb2d69c0d217dff5b1fd83ed0f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#aef5bfdb2d69c0d217dff5b1fd83ed0f5">determine_boundary_vertices_faces</a> ()</td></tr>
<tr class="memdesc:aef5bfdb2d69c0d217dff5b1fd83ed0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through vertices and faces and set the isBoundary} property of boundary vertices and faces to true}.  <br /></td></tr>
<tr class="separator:aef5bfdb2d69c0d217dff5b1fd83ed0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744de61088daa25cc58ae32c07020e5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a744de61088daa25cc58ae32c07020e5d">determine_ghost_vertices_faces</a> ()</td></tr>
<tr class="memdesc:a744de61088daa25cc58ae32c07020e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through vertices and faces and set the isGhost property of ghost vertices and face to true. The number of layers of ghost vertices in a flat membrane is dependent upon the boundary conditions: free boundary condition has 1 layer of ghost vertices and faces while periodic bounary condition has 3 layers of ghost vertices.  <br /></td></tr>
<tr class="separator:a744de61088daa25cc58ae32c07020e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03d9aefdf5b321200fc4f1a6354c1c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ae03d9aefdf5b321200fc4f1a6354c1c8">set_insertion_patch</a> (const vector&lt; vector&lt; int &gt; &gt; &amp;insertionPatch)</td></tr>
<tr class="memdesc:ae03d9aefdf5b321200fc4f1a6354c1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the isInsertionPatch flag for each face in the insertion patch. This also sets with spontaneous curvature after setting the flag with set_spontaneous_curvature_for_face function.  <br /></td></tr>
<tr class="separator:ae03d9aefdf5b321200fc4f1a6354c1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c686d28a291b262ca1c026dba2e817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ae3c686d28a291b262ca1c026dba2e817">set_spontaneous_curvature_for_face</a> (const double &amp;insertCurv, const double &amp;spontCurv)</td></tr>
<tr class="memdesc:ae3c686d28a291b262ca1c026dba2e817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the spontaneous curvature for each face in the mesh.  <br /></td></tr>
<tr class="separator:ae3c686d28a291b262ca1c026dba2e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acaf454a27868a6ed2ff0ddf4aff64e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a0acaf454a27868a6ed2ff0ddf4aff64e">calculate_element_area_volume</a> ()</td></tr>
<tr class="memdesc:a0acaf454a27868a6ed2ff0ddf4aff64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area and volume of each element in the mesh.  <br /></td></tr>
<tr class="separator:a0acaf454a27868a6ed2ff0ddf4aff64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf7a146011c884429c5d5009850d834"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#acbf7a146011c884429c5d5009850d834">sum_membrane_area_and_volume</a> (double &amp;area, double &amp;volume)</td></tr>
<tr class="memdesc:acbf7a146011c884429c5d5009850d834"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the total membrane area and volume of non-ghost faces in a given set of faces.  <br /></td></tr>
<tr class="separator:acbf7a146011c884429c5d5009850d834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3b6819bae35b86e80ba1c4104c8269"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#afe3b6819bae35b86e80ba1c4104c8269">Compute_Energy_And_Force</a> ()</td></tr>
<tr class="memdesc:afe3b6819bae35b86e80ba1c4104c8269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the energy and force on each vertex and face of the mesh.  <br /></td></tr>
<tr class="separator:afe3b6819bae35b86e80ba1c4104c8269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e3994d78b0224d9759fe4ed4b4c6d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ab3e3994d78b0224d9759fe4ed4b4c6d5">element_energy_force_regular</a> (const std::vector&lt; <a class="el" href="classMatrix.html">Matrix</a> &gt; &amp;coordOneRingVertices, <a class="el" href="classFace.html">Face</a> &amp;face, const double spontCurv, double &amp;meanCurv, <a class="el" href="classMatrix.html">Matrix</a> &amp;normVector, double &amp;eBend, <a class="el" href="classMatrix.html">Matrix</a> &amp;fBend, <a class="el" href="classMatrix.html">Matrix</a> &amp;fArea, <a class="el" href="classMatrix.html">Matrix</a> &amp;fVolume)</td></tr>
<tr class="memdesc:ab3e3994d78b0224d9759fe4ed4b4c6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The purpose of this function is to calculate the energy and forces for a regular element of a given mesh using the provided information about the element and its one-ring neighborhood.  <br /></td></tr>
<tr class="separator:ab3e3994d78b0224d9759fe4ed4b4c6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290b3c7dd1e39da6095b5d12da1b2c8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a290b3c7dd1e39da6095b5d12da1b2c8c">energy_force_regularization</a> ()</td></tr>
<tr class="memdesc:a290b3c7dd1e39da6095b5d12da1b2c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the regularization energy and force for each face.  <br /></td></tr>
<tr class="separator:a290b3c7dd1e39da6095b5d12da1b2c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5818bb84a71e7d6e4da2cd0a2da96cfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a5818bb84a71e7d6e4da2cd0a2da96cfb">manage_force_for_boundary_ghost_vertex</a> ()</td></tr>
<tr class="memdesc:a5818bb84a71e7d6e4da2cd0a2da96cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages forces depending on different boundary conditions.  <br /></td></tr>
<tr class="separator:a5818bb84a71e7d6e4da2cd0a2da96cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9a489b9658c52c771d8aeb86761cff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a0d9a489b9658c52c771d8aeb86761cff">get_max_force_magnitude</a> ()</td></tr>
<tr class="memdesc:a0d9a489b9658c52c771d8aeb86761cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the max force scale of vertices.force.get_total_force_magnitude()  <br /></td></tr>
<tr class="separator:a0d9a489b9658c52c771d8aeb86761cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae709a12efd5127a80c9e53298d175b8b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ae709a12efd5127a80c9e53298d175b8b">calculate_mean_force</a> ()</td></tr>
<tr class="memdesc:ae709a12efd5127a80c9e53298d175b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mean force magnitude on all vertices.  <br /></td></tr>
<tr class="separator:ae709a12efd5127a80c9e53298d175b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8f4f14e01b2dc240eedb9ea4d71ff8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ace8f4f14e01b2dc240eedb9ea4d71ff8">update_previous_coord_for_vertex</a> ()</td></tr>
<tr class="memdesc:ace8f4f14e01b2dc240eedb9ea4d71ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the coordPrev member variable for each vertex in the mesh. It does this by copying the current value of coord to coordPrev.  <br /></td></tr>
<tr class="separator:ace8f4f14e01b2dc240eedb9ea4d71ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3789d9eb9e117406a17167c3b9cee1e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a3789d9eb9e117406a17167c3b9cee1e4">update_reference_coord_from_previous_coord</a> ()</td></tr>
<tr class="memdesc:a3789d9eb9e117406a17167c3b9cee1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the reference coordinates for each vertex in the mesh.  <br /></td></tr>
<tr class="separator:a3789d9eb9e117406a17167c3b9cee1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195aba6e11cd1d7a55604c2c337d65c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a195aba6e11cd1d7a55604c2c337d65c4">update_previous_force_for_vertex</a> ()</td></tr>
<tr class="memdesc:a195aba6e11cd1d7a55604c2c337d65c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the previous force vectors for each vertex in the mesh.  <br /></td></tr>
<tr class="separator:a195aba6e11cd1d7a55604c2c337d65c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e83327f9919ee1de80e19f0f3e38a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a79e83327f9919ee1de80e19f0f3e38a6">update_previous_energy_for_face</a> ()</td></tr>
<tr class="memdesc:a79e83327f9919ee1de80e19f0f3e38a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the previous energy values for each face in the mesh.  <br /></td></tr>
<tr class="separator:a79e83327f9919ee1de80e19f0f3e38a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742357b9318965689249acd31601642e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a742357b9318965689249acd31601642e">clear_force_on_vertices_and_energy_on_faces</a> ()</td></tr>
<tr class="memdesc:a742357b9318965689249acd31601642e"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function sets the force member variable of each vertex, and the energy member variable of each face to their default values. This is useful to clear out any residual forces or energies before computing new ones.  <br /></td></tr>
<tr class="separator:a742357b9318965689249acd31601642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbefd57ee3d41858d212263d1dc8024"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a0dbefd57ee3d41858d212263d1dc8024">move_vertices_based_on_scaffolding</a> (bool fixDir=true)</td></tr>
<tr class="memdesc:a0dbefd57ee3d41858d212263d1dc8024"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes in the vector of spline point and calculate the average coordinates. Based on the difference between spline points and mesh vertices, a difference vector is calculated and compared to the target bond length. (Supposed only in Z direction). Afterwards, all the mesh points are moved in the direction of the target difference vector.  <br /></td></tr>
<tr class="separator:a0dbefd57ee3d41858d212263d1dc8024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e11a64d5b45a2ce39b70325f7ff9a4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a6e11a64d5b45a2ce39b70325f7ff9a4e">set_scaffolding_vertices_correspondence</a> ()</td></tr>
<tr class="memdesc:a6e11a64d5b45a2ce39b70325f7ff9a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of indexes of vertices that are closest to the scaffoldingPoints vector provided. Then set the param.scaffoldingPoints_correspondingVertexIndex} to represent the vertices bonded with each scaffolding point.  <br /></td></tr>
<tr class="separator:a6e11a64d5b45a2ce39b70325f7ff9a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4290cf23bd9694e577e9ba73990df3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a9d4290cf23bd9694e577e9ba73990df3">calculate_scaffolding_energy_force</a> (bool doLocalSearch)</td></tr>
<tr class="memdesc:a9d4290cf23bd9694e577e9ba73990df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the energy and force due to the harmonic bond between scaffold points and membrane vertices.  <br /></td></tr>
<tr class="separator:a9d4290cf23bd9694e577e9ba73990df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb6aca91c6fbd690653536eced038bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a5bb6aca91c6fbd690653536eced038bf">write_faces_csv</a> (const std::string &amp;outfile_name)</td></tr>
<tr class="memdesc:a5bb6aca91c6fbd690653536eced038bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a csv file containing the adjacent vertices for each face in the mesh.  <br /></td></tr>
<tr class="separator:a5bb6aca91c6fbd690653536eced038bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24565ddc787b2fd6c78fc8715c5bbd0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a24565ddc787b2fd6c78fc8715c5bbd0a">write_vertices_csv</a> (const std::string &amp;outfile_name)</td></tr>
<tr class="memdesc:a24565ddc787b2fd6c78fc8715c5bbd0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a csv file containing the coordinates of each vertex in the mesh.  <br /></td></tr>
<tr class="separator:a24565ddc787b2fd6c78fc8715c5bbd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac641af43730870056e0ba395856a771a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ac641af43730870056e0ba395856a771a">write_vertices_csv_with_type</a> (const std::string &amp;outfile_name)</td></tr>
<tr class="memdesc:ac641af43730870056e0ba395856a771a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a csv file containing the coordinates and types of each vertex in the mesh.  <br /></td></tr>
<tr class="separator:ac641af43730870056e0ba395856a771a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6465a888c97232a39e12aad008c969c3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classVertex.html">Vertex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a6465a888c97232a39e12aad008c969c3">vertices</a></td></tr>
<tr class="memdesc:a6465a888c97232a39e12aad008c969c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector to store all vertices in the mesh.  <br /></td></tr>
<tr class="separator:a6465a888c97232a39e12aad008c969c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da199719905f2b213f8c0c8feba2d1f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classFace.html">Face</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a9da199719905f2b213f8c0c8feba2d1f">faces</a></td></tr>
<tr class="memdesc:a9da199719905f2b213f8c0c8feba2d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector to store all faces in the mesh.  <br /></td></tr>
<tr class="separator:a9da199719905f2b213f8c0c8feba2d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ce6a4fa3c43202516e8de3504478bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structParam.html">Param</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#ae2ce6a4fa3c43202516e8de3504478bc">param</a></td></tr>
<tr class="memdesc:ae2ce6a4fa3c43202516e8de3504478bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object of the <a class="el" href="structParam.html" title="Contains simulation parameters and physical constants.">Param</a> class containing all necessary parameters for building the <a class="el" href="classMesh.html" title="A class representing a triangular mesh that defines a limit surface.">Mesh</a> object.  <br /></td></tr>
<tr class="separator:ae2ce6a4fa3c43202516e8de3504478bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1820a26272a1ce4209a30032908c92d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a1820a26272a1ce4209a30032908c92d4">enumerate_gauss_quadrature_point_area_volume</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;dots, double &amp;area, double &amp;volume)</td></tr>
<tr class="memdesc:a1820a26272a1ce4209a30032908c92d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private member used in calculating element area volume: Calculates the area and volume at a Gauss quadrature point for a given set of shape functions and dots.  <br /></td></tr>
<tr class="separator:a1820a26272a1ce4209a30032908c92d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e1893669c41ee154462ceb0518a6b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a43e1893669c41ee154462ceb0518a6b0">get_one_ring_vertex_matrix</a> (const <a class="el" href="classFace.html">Face</a> &amp;face)</td></tr>
<tr class="memdesc:a43e1893669c41ee154462ceb0518a6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private member used in calculating element area volume: Computes a matrix containing the coordinates of the one-ring vertices for the input face.  <br /></td></tr>
<tr class="separator:a43e1893669c41ee154462ceb0518a6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a166003a4f1e86bbedfa5ee6867ff0d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a3a166003a4f1e86bbedfa5ee6867ff0d">get_squared_distance_sp_and_v</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;scaffoldingPoint, const <a class="el" href="classVertex.html">Vertex</a> &amp;vertex)</td></tr>
<tr class="memdesc:a3a166003a4f1e86bbedfa5ee6867ff0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private member used in calculating correspondence between scaffolding points and vertices Calculate the squared distance between two points denoted by (3,1) <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> and <a class="el" href="classVertex.html" title="Defines a vertex in Mesh.">Vertex</a> respectively.  <br /></td></tr>
<tr class="separator:a3a166003a4f1e86bbedfa5ee6867ff0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a859d91a1b2b14ee63c792c057d35295a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMesh.html#a859d91a1b2b14ee63c792c057d35295a">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classMesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:a859d91a1b2b14ee63c792c057d35295a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides the operator &lt;&lt; in ostream.  <br /></td></tr>
<tr class="separator:a859d91a1b2b14ee63c792c057d35295a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class representing a triangular mesh that defines a limit surface. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0685f9dfb74d633c092886d56afffb6e" name="a0685f9dfb74d633c092886d56afffb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0685f9dfb74d633c092886d56afffb6e">&#9670;&#160;</a></span>Mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh::Mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParam.html">Param</a> &amp;&#160;</td>
          <td class="paramname"><em>srcParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classMesh.html" title="A class representing a triangular mesh that defines a limit surface.">Mesh</a> object with parameters. Initialize vertices and faces with other functions like setVerticesFlat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaab78f3a30742a937d9a387287ce323c" name="aaab78f3a30742a937d9a387287ce323c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab78f3a30742a937d9a387287ce323c">&#9670;&#160;</a></span>Mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh::Mesh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVertex.html">Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classFace.html">Face</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParam.html">Param</a> &amp;&#160;</td>
          <td class="paramname"><em>srcParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new mesh object with given vertices, faces, and parameters. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This function is deprecated, initialize with <a class="el" href="classMesh.html#a0685f9dfb74d633c092886d56afffb6e" title="Construct a new Mesh object with parameters. Initialize vertices and faces with other functions like ...">Mesh(Param &amp;srcParam)</a> and setup with setup_from_vertices_faces instead. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0acaf454a27868a6ed2ff0ddf4aff64e" name="a0acaf454a27868a6ed2ff0ddf4aff64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acaf454a27868a6ed2ff0ddf4aff64e">&#9670;&#160;</a></span>calculate_element_area_volume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::calculate_element_area_volume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the area and volume of each element in the mesh. </p>
<p>This method computes and sets the area and volume of each element in the mesh, where an "element" refers to a face in the mesh. The method uses Gaussian quadrature to calculate the area and volume of each element, with 3 points used for regular patches and multiple iterations of subdivision used for irregular patches.</p>
<p>The method first defines some matrices used for subdivision of the irregular patch, including <code>M</code>, <code>M1</code>, <code>M2</code>, <code>M3</code>, and <code>M4</code>. It then loops over all faces in the mesh in parallel using OpenMP.</p>
<p>For each face, the method checks whether it is a ghost face; if so, it skips to the next face. Otherwise, it initializes variables to accumulate the area and volume of the element and determines the number of one-ring vertices (<code>nOneRingVertex</code>) for the face.</p>
<p>If <code>nOneRingVertex</code> is equal to 12, the face corresponds to a regular patch, and the method calls the <code>get_one_ring_vertex_matrix</code> function to compute a matrix representing the coordinates of the one-ring vertices. It then uses Gaussian quadrature with 3 points to compute the area and volume of the element.</p>
<p>If <code>nOneRingVertex</code> is equal to 11, the face corresponds to an irregular patch. In this case, the method again calls <code>get_one_ring_vertex_matrix</code> to compute the matrix of one-ring vertex coordinates, but then performs multiple iterations of subdivision using the <code>M</code>, <code>M1</code>, <code>M2</code>, <code>M3</code>, and <code>M4</code> matrices to estimate the area and volume of the element.</p>
<p>Finally, the method sets the <code>elementArea</code> and <code>elementVolume</code> member variables of the face to the computed area and volume, respectively. </p>

</div>
</div>
<a id="ae709a12efd5127a80c9e53298d175b8b" name="ae709a12efd5127a80c9e53298d175b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae709a12efd5127a80c9e53298d175b8b">&#9670;&#160;</a></span>calculate_mean_force()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Mesh::calculate_mean_force </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mean force magnitude on all vertices. </p>
<dl class="section return"><dt>Returns</dt><dd>mean force magnitude </dd></dl>

</div>
</div>
<a id="a9d4290cf23bd9694e577e9ba73990df3" name="a9d4290cf23bd9694e577e9ba73990df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4290cf23bd9694e577e9ba73990df3">&#9670;&#160;</a></span>calculate_scaffolding_energy_force()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Mesh::calculate_scaffolding_energy_force </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doLocalSearch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the energy and force due to the harmonic bond between scaffold points and membrane vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doLocalSearch</td><td>Flag indicating whether or not to perform a local search for each vertex (default=false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The total energy of the system due to the scaffold-membrane interactions.</dd></dl>
<p>The function iterates over each scaffold point, calculates the distance between the point and its corresponding vertex, and calculates the energy and force due to the harmonic bond between the two. If the energy flag is not set to include harmonic bonding, the function returns 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">doLocalSearch</td><td>Flag to indicate whether a local search should be performed for each vertex (default=false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The energy is calculated according to the formula: E = 0.5 * k * (r - l)^2, where k is the spring constant, r is the distance between the scaffold point and vertex, and l is the resting length of the bond. </dd>
<dd>
The force is calculated according to the formula: F = -k * (r - l) * (unit vector pointing from vertex to scaffold point). </dd>
<dd>
If the distance between the scaffold point and vertex is negative, the force is multiplied by -1 in order to prevent overlapping between the scaffold and membrane. </dd>
<dd>
If the verbose flag is set, the function prints out information about each vertex's force due to the scaffold-membrane bond. </dd></dl>

</div>
</div>
<a id="a742357b9318965689249acd31601642e" name="a742357b9318965689249acd31601642e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742357b9318965689249acd31601642e">&#9670;&#160;</a></span>clear_force_on_vertices_and_energy_on_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::clear_force_on_vertices_and_energy_on_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function sets the force member variable of each vertex, and the energy member variable of each face to their default values. This is useful to clear out any residual forces or energies before computing new ones. </p>

</div>
</div>
<a id="afe3b6819bae35b86e80ba1c4104c8269" name="afe3b6819bae35b86e80ba1c4104c8269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3b6819bae35b86e80ba1c4104c8269">&#9670;&#160;</a></span>Compute_Energy_And_Force()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::Compute_Energy_And_Force </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the energy and force on each vertex and face of the mesh. </p>
<p>This function performs the following steps: Calculates the area and volume of each element triangle and sums up the total area and volume of the membrane. Iterates through faces and calculates the energy and force on each triangular patch. Regularizes the force and energy. Sums up the energy and force on each vertex and face. Calculates the energy due to area constraint. Calculates the energy due to volume constraint. Calculates the energy due to scaffolding.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="aef5bfdb2d69c0d217dff5b1fd83ed0f5" name="aef5bfdb2d69c0d217dff5b1fd83ed0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5bfdb2d69c0d217dff5b1fd83ed0f5">&#9670;&#160;</a></span>determine_boundary_vertices_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::determine_boundary_vertices_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate through vertices and faces and set the isBoundary} property of boundary vertices and faces to true}. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Currently the isBoundary property is not used in any part of the model. This is a placeholder in case any future functions need the property. </dd></dl>

</div>
</div>
<a id="a744de61088daa25cc58ae32c07020e5d" name="a744de61088daa25cc58ae32c07020e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744de61088daa25cc58ae32c07020e5d">&#9670;&#160;</a></span>determine_ghost_vertices_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::determine_ghost_vertices_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate through vertices and faces and set the isGhost property of ghost vertices and face to true. The number of layers of ghost vertices in a flat membrane is dependent upon the boundary conditions: free boundary condition has 1 layer of ghost vertices and faces while periodic bounary condition has 3 layers of ghost vertices. </p>

</div>
</div>
<a id="ab3e3994d78b0224d9759fe4ed4b4c6d5" name="ab3e3994d78b0224d9759fe4ed4b4c6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e3994d78b0224d9759fe4ed4b4c6d5">&#9670;&#160;</a></span>element_energy_force_regular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::element_energy_force_regular </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMatrix.html">Matrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coordOneRingVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFace.html">Face</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>spontCurv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>meanCurv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>normVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>eBend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>fBend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>fArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>fVolume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The purpose of this function is to calculate the energy and forces for a regular element of a given mesh using the provided information about the element and its one-ring neighborhood. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordOneRingVertices</td><td>a constant reference to a vector of matrices representing the coordinates of the vertices in the mesh's one-ring neighborhood. </td></tr>
    <tr><td class="paramname">spontCurv</td><td>a constant double representing the spontaneous curvature. </td></tr>
    <tr><td class="paramname">meanCurv</td><td>a non-constant double reference representing the mean curvature of the element. </td></tr>
    <tr><td class="paramname">normVector</td><td>a non-constant matrix reference representing the normal vector of the element. </td></tr>
    <tr><td class="paramname">eBend</td><td>a non-constant double reference representing the bending energy of the element. </td></tr>
    <tr><td class="paramname">fBend</td><td>a non-constant matrix reference representing the bending force of the element. </td></tr>
    <tr><td class="paramname">fArea</td><td>a non-constant matrix reference representing the area constraint force of the element. </td></tr>
    <tr><td class="paramname">fVolume</td><td>a non-constant matrix reference representing the volume constraint force of the element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a290b3c7dd1e39da6095b5d12da1b2c8c" name="a290b3c7dd1e39da6095b5d12da1b2c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290b3c7dd1e39da6095b5d12da1b2c8c">&#9670;&#160;</a></span>energy_force_regularization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::energy_force_regularization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the regularization energy and force for each face. </p>
<p>This function calculates the regularization energy and force for each face in the mesh. The regularization energy is calculated based on the deformation of the face's shape and area relative to an equilateral triangle with the same side length. The regularization force is then calculated based on the energy and applied to the vertices of the face. The function also updates the deformation counts for shapes and areas.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a1820a26272a1ce4209a30032908c92d4" name="a1820a26272a1ce4209a30032908c92d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1820a26272a1ce4209a30032908c92d4">&#9670;&#160;</a></span>enumerate_gauss_quadrature_point_area_volume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::enumerate_gauss_quadrature_point_area_volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>dots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private member used in calculating element area volume: Calculates the area and volume at a Gauss quadrature point for a given set of shape functions and dots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dots</td><td>The matrix of dots representing the coordinates of the quadrature point. </td></tr>
    <tr><td class="paramname">gaussQuadratureCoeff</td><td>The matrix of Gauss quadrature coefficients. </td></tr>
    <tr><td class="paramname">area</td><td>A reference to a double variable storing the accumulated area. </td></tr>
    <tr><td class="paramname">volume</td><td>A reference to a double variable storing the accumulated volume. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae93250c015872ef461069e436ec0d7be" name="ae93250c015872ef461069e436ec0d7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93250c015872ef461069e436ec0d7be">&#9670;&#160;</a></span>find_opposite_node_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mesh::find_opposite_node_index </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>node2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>node3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the vertex that is adjacent to node1 and node2 but not node3. Particularly, when the three nodes are vertices of a triangle, then the function returns the the index of node4 that forms a parallegram with 1-&gt;3-&gt;2-&gt;4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td></td></tr>
    <tr><td class="paramname">node2</td><td></td></tr>
    <tr><td class="paramname">node3</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int vertex index </dd></dl>

</div>
</div>
<a id="a0d9a489b9658c52c771d8aeb86761cff" name="a0d9a489b9658c52c771d8aeb86761cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9a489b9658c52c771d8aeb86761cff">&#9670;&#160;</a></span>get_max_force_magnitude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Mesh::get_max_force_magnitude </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the max force scale of vertices.force.get_total_force_magnitude() </p>
<dl class="section return"><dt>Returns</dt><dd>double max force magnitude </dd></dl>

</div>
</div>
<a id="a43e1893669c41ee154462ceb0518a6b0" name="a43e1893669c41ee154462ceb0518a6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e1893669c41ee154462ceb0518a6b0">&#9670;&#160;</a></span>get_one_ring_vertex_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> Mesh::get_one_ring_vertex_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFace.html">Face</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private member used in calculating element area volume: Computes a matrix containing the coordinates of the one-ring vertices for the input face. </p>

</div>
</div>
<a id="a3a166003a4f1e86bbedfa5ee6867ff0d" name="a3a166003a4f1e86bbedfa5ee6867ff0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a166003a4f1e86bbedfa5ee6867ff0d">&#9670;&#160;</a></span>get_squared_distance_sp_and_v()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Mesh::get_squared_distance_sp_and_v </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>scaffoldingPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVertex.html">Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private member used in calculating correspondence between scaffolding points and vertices Calculate the squared distance between two points denoted by (3,1) <a class="el" href="classMatrix.html" title="Matrix used in continuum membrane model.">Matrix</a> and <a class="el" href="classVertex.html" title="Defines a vertex in Mesh.">Vertex</a> respectively. </p>
<dl class="section return"><dt>Returns</dt><dd>the squared distance </dd></dl>

</div>
</div>
<a id="a5818bb84a71e7d6e4da2cd0a2da96cfb" name="a5818bb84a71e7d6e4da2cd0a2da96cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5818bb84a71e7d6e4da2cd0a2da96cfb">&#9670;&#160;</a></span>manage_force_for_boundary_ghost_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::manage_force_for_boundary_ghost_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manages forces depending on different boundary conditions. </p>
<p>This method sets the force of nodes that are part of the mesh's boundaries and ghost vertices to zero, based on the type of boundary condition specified in the input parameters.</p>
<dl class="section note"><dt>Note</dt><dd>See enum BoundaryType in <a class="el" href="Parameters_8hpp.html" title="This file defines essential parameters used in continuum membrane as well as membrane dynamics code....">Parameters.hpp</a> </dd></dl>

</div>
</div>
<a id="a0dbefd57ee3d41858d212263d1dc8024" name="a0dbefd57ee3d41858d212263d1dc8024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbefd57ee3d41858d212263d1dc8024">&#9670;&#160;</a></span>move_vertices_based_on_scaffolding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Mesh::move_vertices_based_on_scaffolding </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fixDir</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method takes in the vector of spline point and calculate the average coordinates. Based on the difference between spline points and mesh vertices, a difference vector is calculated and compared to the target bond length. (Supposed only in Z direction). Afterwards, all the mesh points are moved in the direction of the target difference vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixDir</td><td>default to true; fix move vector to (0, 0, 50) if set to true; otherwise move vector is determined based on average scaffolding points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success </dd></dl>

</div>
</div>
<a id="aed33be097663033bc75853c33c3333ed" name="aed33be097663033bc75853c33c3333ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed33be097663033bc75853c33c3333ed">&#9670;&#160;</a></span>set_adjacent_faces_of_vertices_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::set_adjacent_faces_of_vertices_sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set adjacentFaces properties based on the current vertices and mesh. Sort the adjacent vertices so that the adjacent vertices property of vertices follow the counterclockwise order and therefore the the adjacent faces with index number difference of one are adjacent to each other. This sorting streamlines the shapefunction calculation. </p>

</div>
</div>
<a id="a3701b70db1a2940cbda09d8d8ae36dc0" name="a3701b70db1a2940cbda09d8d8ae36dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3701b70db1a2940cbda09d8d8ae36dc0">&#9670;&#160;</a></span>set_adjacent_vertices_of_vertices_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::set_adjacent_vertices_of_vertices_sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set adjacentVertices of vertices based on current mesh. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Sorting to be implemented.</dd></dl>

</div>
</div>
<a id="a99b21ba1a874da6dc75cfa473d02a747" name="a99b21ba1a874da6dc75cfa473d02a747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b21ba1a874da6dc75cfa473d02a747">&#9670;&#160;</a></span>set_axes_division_flat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::set_axes_division_flat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide x,y axis to nx*dx (number of faces times length of each face) and ny*dy based on X, Y side length of the mesh and side length of faces in parameter. Note: </p>
<p>(1) y-axis is in a zig-zag shape and in perpendicular direction, h(y) = sqrt(3)/2 * h(x) assuming equilateral triangles (2) number of vertices along axes = number of faces (edges) + 1 </p>

</div>
</div>
<a id="ae03d9aefdf5b321200fc4f1a6354c1c8" name="ae03d9aefdf5b321200fc4f1a6354c1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03d9aefdf5b321200fc4f1a6354c1c8">&#9670;&#160;</a></span>set_insertion_patch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::set_insertion_patch </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>insertionPatch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the isInsertionPatch flag for each face in the insertion patch. This also sets with spontaneous curvature after setting the flag with set_spontaneous_curvature_for_face function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insertionPatch</td><td>A vector of vectors containing the indices of faces in the insertion patch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83c95e1c6ae386b81d44558273b10a1e" name="a83c95e1c6ae386b81d44558273b10a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c95e1c6ae386b81d44558273b10a1e">&#9670;&#160;</a></span>set_one_ring_vertices_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::set_one_ring_vertices_sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find out the one-ring vertices aound face_i. It should be 12 for the flat surface because we set it up only with regular patch. The boundary faces do not have complete one-ring, neither it will be called in the code, so no need to store their one-ring-vertex </p>

</div>
</div>
<a id="a6e11a64d5b45a2ce39b70325f7ff9a4e" name="a6e11a64d5b45a2ce39b70325f7ff9a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e11a64d5b45a2ce39b70325f7ff9a4e">&#9670;&#160;</a></span>set_scaffolding_vertices_correspondence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::set_scaffolding_vertices_correspondence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a vector of indexes of vertices that are closest to the scaffoldingPoints vector provided. Then set the param.scaffoldingPoints_correspondingVertexIndex} to represent the vertices bonded with each scaffolding point. </p>

</div>
</div>
<a id="ae3c686d28a291b262ca1c026dba2e817" name="ae3c686d28a291b262ca1c026dba2e817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c686d28a291b262ca1c026dba2e817">&#9670;&#160;</a></span>set_spontaneous_curvature_for_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::set_spontaneous_curvature_for_face </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>insertCurv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>spontCurv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the spontaneous curvature for each face in the mesh. </p>
<p>This method sets the "spontaneous curvature" of each face in the mesh, which is a parameter used to describe the shape and behavior of lipid membranes. The spontaneous curvature can be different for faces inside and outside of an "insertion patch," which are specified by the <code>insertCurv</code> and <code>spontCurv</code> parameters, respectively.</p>
<p>The method takes two double parameters: <code>insertCurv</code> and <code>spontCurv</code>. The former specifies the spontaneous curvature for faces within the insertion patch, while the latter specifies the spontaneous curvature for faces outside of the insertion patch.</p>
<p>The method loops over all faces in the mesh and sets the <code>spontCurvature</code> member variable of each face to either <code>insertCurv</code> or <code>spontCurv</code>, depending on whether the face is part of the insertion patch or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insertCurv</td><td>The spontaneous curvature for faces in the insertion patch </td></tr>
    <tr><td class="paramname">spontCurv</td><td>The spontaneous curvature for faces outside the insertion patch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac531dabf200ff831464999c03f345707" name="ac531dabf200ff831464999c03f345707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac531dabf200ff831464999c03f345707">&#9670;&#160;</a></span>set_vertices_faces_flat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::set_vertices_faces_flat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set vertices and faces according to mesh and face side lengths in param for flat mesh. This also sets adjacent vertices of faces. </p>

</div>
</div>
<a id="affdc2aaee5e4762f56c6637b16506f2d" name="affdc2aaee5e4762f56c6637b16506f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdc2aaee5e4762f56c6637b16506f2d">&#9670;&#160;</a></span>setup_flat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::setup_flat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize halfedges based on the mesh's vertices and faces. </p>
<p>Helper function to create a new halfedge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexIndex</td><td>Index of the vertex associated with the halfedge. </td></tr>
    <tr><td class="paramname">faceIndex</td><td>Index of the face associated with the halfedge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Halfedge* Pointer to the created halfedge.</dd></dl>
<p>Initialize flat membrane with properities specified in the param} member variable. Equivalent to call: (1) this-&gt;set_axes_division_flat (2) this-&gt;set_vertices_faces_flat (3) this-&gt;set_adjacent_faces_of_vertices_sorted (4) this-&gt;determine_ghost_vertices_faces </p>

</div>
</div>
<a id="a9573e3cbf642233168d9a6e70d5a1a57" name="a9573e3cbf642233168d9a6e70d5a1a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9573e3cbf642233168d9a6e70d5a1a57">&#9670;&#160;</a></span>setup_from_vertices_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::setup_from_vertices_faces </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>verticesData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>facesData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize membrane with arbitrary vertices and faces imported from files. Sets up the membrane from data and then call: (1) this-&gt;set_adjacent_faces_of_vertices_sorted (2) this-&gt;determine_ghost_vertices_faces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verticesData</td><td>2D double vector containing the coordinates of vertices </td></tr>
    <tr><td class="paramname">facesData</td><td>2D int vector containing the indices of vertices on each face </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbf7a146011c884429c5d5009850d834" name="acbf7a146011c884429c5d5009850d834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf7a146011c884429c5d5009850d834">&#9670;&#160;</a></span>sum_membrane_area_and_volume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::sum_membrane_area_and_volume </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the total membrane area and volume of non-ghost faces in a given set of faces. </p>
<dl class="section note"><dt>Note</dt><dd>This function only sums up to element area and volume of all faces. It does not update the element area and volume based on the current state of the mesh. If you need to update and calculate the total area and volume of the mesh, please call calculate_element_area_volume first before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">area</td><td>a reference to a double variable to store the computed area </td></tr>
    <tr><td class="paramname">volume</td><td>a reference to a double variable to store the computed volume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace8f4f14e01b2dc240eedb9ea4d71ff8" name="ace8f4f14e01b2dc240eedb9ea4d71ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8f4f14e01b2dc240eedb9ea4d71ff8">&#9670;&#160;</a></span>update_previous_coord_for_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::update_previous_coord_for_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates the coordPrev member variable for each vertex in the mesh. It does this by copying the current value of coord to coordPrev. </p>

</div>
</div>
<a id="a79e83327f9919ee1de80e19f0f3e38a6" name="a79e83327f9919ee1de80e19f0f3e38a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e83327f9919ee1de80e19f0f3e38a6">&#9670;&#160;</a></span>update_previous_energy_for_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::update_previous_energy_for_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the previous energy values for each face in the mesh. </p>
<p>The <code>energyPrev</code> member variable for each face is updated with the current value of <code>energy</code>. </p>

</div>
</div>
<a id="a195aba6e11cd1d7a55604c2c337d65c4" name="a195aba6e11cd1d7a55604c2c337d65c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195aba6e11cd1d7a55604c2c337d65c4">&#9670;&#160;</a></span>update_previous_force_for_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::update_previous_force_for_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the previous force vectors for each vertex in the mesh. </p>
<p>The <code>forcePrev</code> member variable for each vertex is updated with the current value of <code>force</code>. </p>

</div>
</div>
<a id="a3789d9eb9e117406a17167c3b9cee1e4" name="a3789d9eb9e117406a17167c3b9cee1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3789d9eb9e117406a17167c3b9cee1e4">&#9670;&#160;</a></span>update_reference_coord_from_previous_coord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::update_reference_coord_from_previous_coord </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the reference coordinates for each vertex in the mesh. </p>
<p>The <code>coordRef</code> member variable for each vertex is updated with the current value of <code>coordPrev</code>. </p>

</div>
</div>
<a id="a5bb6aca91c6fbd690653536eced038bf" name="a5bb6aca91c6fbd690653536eced038bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb6aca91c6fbd690653536eced038bf">&#9670;&#160;</a></span>write_faces_csv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::write_faces_csv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outfile_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a csv file containing the adjacent vertices for each face in the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outfile_name</td><td>The name of the output csv file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24565ddc787b2fd6c78fc8715c5bbd0a" name="a24565ddc787b2fd6c78fc8715c5bbd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24565ddc787b2fd6c78fc8715c5bbd0a">&#9670;&#160;</a></span>write_vertices_csv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::write_vertices_csv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outfile_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a csv file containing the coordinates of each vertex in the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outfile_name</td><td>The name of the output csv file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac641af43730870056e0ba395856a771a" name="ac641af43730870056e0ba395856a771a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac641af43730870056e0ba395856a771a">&#9670;&#160;</a></span>write_vertices_csv_with_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::write_vertices_csv_with_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outfile_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a csv file containing the coordinates and types of each vertex in the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outfile_name</td><td>The name of the output csv file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a859d91a1b2b14ee63c792c057d35295a" name="a859d91a1b2b14ee63c792c057d35295a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859d91a1b2b14ee63c792c057d35295a">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overrides the operator &lt;&lt; in ostream. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9da199719905f2b213f8c0c8feba2d1f" name="a9da199719905f2b213f8c0c8feba2d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da199719905f2b213f8c0c8feba2d1f">&#9670;&#160;</a></span>faces</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classFace.html">Face</a>&gt; Mesh::faces</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector to store all faces in the mesh. </p>

</div>
</div>
<a id="ae2ce6a4fa3c43202516e8de3504478bc" name="ae2ce6a4fa3c43202516e8de3504478bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ce6a4fa3c43202516e8de3504478bc">&#9670;&#160;</a></span>param</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structParam.html">Param</a>&amp; Mesh::param</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Object of the <a class="el" href="structParam.html" title="Contains simulation parameters and physical constants.">Param</a> class containing all necessary parameters for building the <a class="el" href="classMesh.html" title="A class representing a triangular mesh that defines a limit surface.">Mesh</a> object. </p>

</div>
</div>
<a id="a6465a888c97232a39e12aad008c969c3" name="a6465a888c97232a39e12aad008c969c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6465a888c97232a39e12aad008c969c3">&#9670;&#160;</a></span>vertices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classVertex.html">Vertex</a>&gt; Mesh::vertices</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector to store all vertices in the mesh. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="Mesh_8hpp_source.html">Mesh.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
